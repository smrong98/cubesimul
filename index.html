<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>잠재능력(큐브) 재설정 시뮬레이터</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background:#121212;
      color:#e5e7eb;
      margin:0;
      padding:16px;
    }
    h1 {
      margin:0 0 0px;
      font-size:1.4rem;
      color:#8CAF0B;
    }
    .subtitle {
      font-size:1rem;
      color:#6d831b;
      font-weight:600;
    }
    .page-meta {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      font-size:0.85rem;
      color:#a1a1aa;
      line-height:1.2;
      margin-bottom:14px;
    }

    .layout {
      display:grid;
      grid-template-columns: minmax(280px, 340px) minmax(320px, 1fr);
      gap:16px;
      align-items:start;
    }
    .layout-column {
      display:flex;
      flex-direction:column;
      gap:16px;
      align-items:stretch;
    }
    @media (max-width: 768px) {
      .layout {
        display:flex;
        flex-direction:column;
        align-items:stretch;
      }
      .layout-column {
        gap:16px;
        width:100%;
      }
    }

    .card {
      background:#1e1e1e;
      border:1px solid #2d2d2d;
      border-radius:12px;
      padding:12px 14px;
      box-shadow:0 10px 30px rgba(0,0,0,0.6);
    }
    .card h2 {
      margin:0 0 8px;
      font-size:1rem;
      border-bottom:1px solid #2d2d2d;
      padding-bottom:4px;
      color:#ffffff;
    }
    @media (max-width: 768px) {
      .card {
        width:100%;
      }
    }

    label {
      font-size:0.85rem;
      display:block;
      margin-bottom:4px;
    }
    input[type="number"],
    select {
      width:100%;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #3f3f46;
      background:#111111;
      color:#e5e7eb;
      font-size:0.9rem;
    }
    input[type="radio"] {
      transform:translateY(1px);
      margin-right:4px;
    }
    .row {
      display:flex;
      gap:8px;
      margin-bottom:8px;
    }
    .row > div { flex:1; }

    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 12px;
      border-radius:999px;
      border:none;
      cursor:pointer;
      font-size:0.9rem;
      font-weight:600;
      transition:transform 0.06s ease, box-shadow 0.06s ease, background 0.1s;
      white-space:nowrap;
    }
    .btn-primary {
      background:linear-gradient(135deg,#8CAF0B,#a9d51a);
      color:#111827;
      box-shadow:0 10px 25px rgba(140,175,11,0.45);
    }
    .btn-primary:active {
      transform:translateY(1px) scale(.99);
      box-shadow:0 4px 12px rgba(140,175,11,0.35);
    }
    .btn-secondary {
      background:#27272a;
      color:#e5e7eb;
      border:1px solid #3f3f46;
    }
    .btn-secondary:active {
      transform:translateY(1px) scale(.99);
      box-shadow:0 4px 12px rgba(0,0,0,0.7);
    }

    .options-layout {
      margin-top:8px;
      display:grid;
      grid-template-columns:repeat(3, minmax(0,1fr));
      grid-auto-rows:auto;
      gap:8px;
      align-items:start;
    }
    #box-current {
      grid-column:2 / 3;
      grid-row:1;
    }
    #box-roll1 {
      grid-column:1 / 2;
      grid-row:2;
    }
    #box-roll2 {
      grid-column:2 / 3;
      grid-row:2;
    }
    #box-roll3 {
      grid-column:3 / 4;
      grid-row:2;
    }
    @media (max-width: 640px) {
      .options-layout {
        display:flex;
        flex-direction:column;
      }
      #box-current,
      #box-roll1,
      #box-roll2,
      #box-roll3 {
        grid-column:auto;
        grid-row:auto;
      }
    }

    .option-box {
      width:100%;
      min-height:120px;
      border-radius:12px;
      border:1px solid #303030;
      background:radial-gradient(circle at top, #252525 0, #111111 60%);
      font-size:0.8rem;
      position:relative;
      overflow:hidden;
      box-shadow:0 6px 18px rgba(0,0,0,0.55);
      transition:transform 0.08s ease, box-shadow 0.08s ease, border-color 0.08s ease;
      opacity:1;
    }
    .option-box.current {
      border-color:#8CAF0B;
      box-shadow:0 0 0 1px rgba(140,175,11,0.4), 0 6px 18px rgba(0,0,0,0.7);
    }

    .option-title {
      margin:-1px -1px 6px -1px;
      padding:4px 10px;
      background:linear-gradient(180deg, #8CAF0B, #5f7a07);
      border-radius:10px 10px 0 0;
      border-bottom:1px solid #141414;
      font-size:0.75rem;
      font-weight:600;
      color:#f9fafb;
      text-align:center;
      text-shadow:0 1px 1px rgba(0,0,0,0.7);
    }

    .option-inner {
      padding:4px 8px 8px;
    }

    .option-lines div {
      margin-bottom:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .option-box.candidate {
      cursor:pointer;
    }
    .option-box.candidate:hover {
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,0.75);
      border-color:#8CAF0B;
    }
    .option-box.candidate:active {
      transform:translateY(0);
      box-shadow:0 6px 16px rgba(0,0,0,0.7);
    }

    /* 자동돌리기 성공 하이라이트: 테두리는 그대로 두고, 바깥으로 퍼지는 골드 글로우 */
    .option-box.auto-hit {
      box-shadow:
        0 0 14px rgba(255,225,130,0.45),   /* 중심 밝기 ↑ */
        0 0 30px rgba(255,210,110,0.32),
        0 0 60px rgba(255,210,110,0.22),
        0 0 90px rgba(255,210,110,0.12),
        0 10px 24px rgba(0,0,0,0.75);
    }


    /* 번쩍 효과(짧게): 글로우 강도만 순간적으로 올렸다가 내려감 */
    @keyframes autoHitFlash {
      0% {
        box-shadow:
          0 0 14px rgba(255,215,120,0.25),
          0 0 30px rgba(255,215,120,0.18),
          0 0 60px rgba(255,215,120,0.10),
          0 10px 24px rgba(0,0,0,0.75);
      }
      45% {
        box-shadow:
          0 0 22px rgba(255,235,150,0.85),  /* 핵심 */
          0 0 44px rgba(255,220,130,0.55),
          0 0 80px rgba(255,220,130,0.35),
          0 0 120px rgba(255,220,130,0.20),
          0 10px 24px rgba(0,0,0,0.75);
      }
      100% {
        box-shadow:
          0 0 14px rgba(255,215,120,0.45),
          0 0 30px rgba(255,215,120,0.32),
          0 0 60px rgba(255,215,120,0.22),
          0 10px 24px rgba(0,0,0,0.75);
      }
    }


    .option-box.auto-hit-flash {
      animation: autoHitFlash 0.9s ease-out;
    }



    @keyframes fadeInFast {
      from { opacity:0; transform:translateY(4px); }
      to   { opacity:1; transform:translateY(0); }
    }
    .fade-in-fast {
      animation:fadeInFast 0.18s ease-out;
    }

    @keyframes fadeOutCard {
      from { opacity:1; transform:scale(1); }
      to   { opacity:0; transform:scale(0.98); }
    }
    .fade-out-card {
      animation:fadeOutCard 0.15s ease-out;
    }
    @keyframes fadeInCard {
      from { opacity:0; transform:translateY(-2px); }
      to   { opacity:1; transform:translateY(0); }
    }
    .fade-in-card {
      animation:fadeInCard 0.2s ease-out;
    }

    .stats-row {
      margin-top:6px;
      font-size:0.9rem;
      display:flex;
      flex-direction:column;
      gap:4px;
    }

    #log {
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,"Liberation Mono","Courier New", monospace;
      font-size:0.75rem;
      max-height:260px;
      overflow-y:auto;
      padding:6px 8px;
      background:#111111;
      border-radius:8px;
      border:1px solid #27272a;
      white-space:pre-wrap;
    }

    .tag {
      display:inline-flex;
      align-items:center;
      gap:4px;
      font-size:0.75rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid #3f3f46;
      background:#111111;
      margin-top:4px;
      width:max-content;
    }
    .tag-dot {
      width:6px;
      height:6px;
      border-radius:999px;
      background:#8CAF0B;
    }

    .log-header-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .log-header-row span {
      font-size:1rem;
    }
    .log-toggle-btn {
      border-radius:999px;
      border:1px solid #3f3f46;
      background:#111111;
      color:#e5e7eb;
      font-size:0.75rem;
      padding:2px 8px;
      cursor:pointer;
    }
    .log-toggle-btn:hover {
      background:#1f1f1f;
    }

    #card-settings,
    #card-options,
    #card-stats,
    #card-log {
      width:100%;
    }
  </style>
    <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VZJQL22RBV"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-VZJQL22RBV');
  </script>
</head>
<body>
  <h1>잠재능력 재설정 시뮬레이터</h1>
  <div class="subtitle">큐브 시뮬레이터</div>
  <div class="page-meta">
    <span id="updateDate"></span>
    <span>/ 제작: 크로아 - 윈메롱</span>
  </div>

  <div class="layout">
    <div class="layout-column">
      <!-- 1. 설정 카드 -->
      <section class="card" id="card-settings">
        <h2>설정</h2>

        <!-- 내 장비 불러오기 (Nexon Open API) -->
        <div style="margin-top:10px; padding-top:10px; border-top:1px dashed #2d2d2d;">
          <label style="margin-bottom:6px; font-size:0.9rem;">
            <input type="checkbox" id="useMyEquipToggle" />
            내 장비 불러오기 (API Key 필요)
          </label>

          <div id="myEquipPanel" style="display:none; margin-top:8px;">
            <div class="row">
              <div>
                <label for="nxApiKey">Nexon Open API Key</label>
                <input id="nxApiKey" type="password" placeholder="x-nxopen-api-key" style="width:100%; padding:6px 8px; border-radius:8px; border:1px solid #3f3f46; background:#111111; color:#e5e7eb; font-size:0.9rem;" />
                <div style="display:flex; gap:8px; align-items:center; margin-top:6px;">
                  <button type="button" class="btn btn-secondary" id="clearApiKeyBtn" style="padding:6px 10px; font-size:0.8rem;">저장된 키 삭제</button>
                </div>
              </div>
              <div>
                <label for="characterName">캐릭터 닉네임</label>
                <input id="characterName" type="text" placeholder="닉네임" style="width:100%; padding:6px 8px; border-radius:8px; border:1px solid #3f3f46; background:#111111; color:#e5e7eb; font-size:0.9rem;" />
                <div style="display:flex; gap:8px; margin-top:10px;">
                  <button type="button" class="btn btn-primary" id="fetchMyEquipBtn" style="flex:1;">장비 불러오기</button>
                </div>
                <div id="myEquipStatus" style="margin-top:6px; font-size:0.8rem; color:#a1a1aa;"></div>
              </div>
            </div>

            <div class="row" style="margin-top:6px;">
              <div>
                <label for="equipPreset">프리셋</label>
                <select id="equipPreset">
                  <option value="1" selected>프리셋 1</option>
                  <option value="2">프리셋 2</option>
                  <option value="3">프리셋 3</option>
                </select>
              </div>
              <div>
                <label for="myEquipSelect">장비 선택 (레전만 가능)</label>
                <select id="myEquipSelect" disabled>
                  <option value="">(먼저 장비를 불러오세요)</option>
                </select>
              </div>
            </div>

            <div class="row" style="margin-top:6px;">
              <div>
                <label>자동 설정</label>
                <div style="font-size:0.85rem; color:#e5e7eb;">
                  <div>부위/레벨: <span id="myEquipAutoPartLevel" style="color:#a1a1aa;">-</span></div>
                  <div style="margin-top:4px;">시작 옵션: <span style="color:#a1a1aa;">선택한 아이템의 잠재로 현재 옵션이 설정됩니다</span></div>
                  <div style="margin-top:4px;">잠재 상태: <span id="myEquipSideHint" style="color:#a1a1aa;">-</span></div>
                </div>
              </div>
            </div>

            <div style="margin-top:6px; font-size:0.75rem; color:#71717a; line-height:1.35;">
              * Open API는 데이터 반영이 지연될 수 있습니다. 기본 조회일자는 “전일(어제)”입니다.
            </div>
          </div>
        </div>


      <div class="row">
        <div>
          <label for="itemLevel">아이템 레벨</label>
          <select id="itemLevel">
            <option value="100">100</option>
            <option value="120">120</option>
            <option value="130">130</option>
            <option value="140">140</option>
            <option value="150">150</option>
            <option value="160">160</option>
            <option value="200" selected>200</option>
            <option value="250">250</option>
          </select>
        </div>
        <div>
          <label for="partsType">장비 부위</label>
          <select id="partsType">
            <option value="1">무기</option>
            <option value="2">엠블렘</option>
            <option value="3">보조무기(포스실드 제외)</option>
            <option value="4">포스실드/소울링</option>
            <option value="5">방패</option>
            <option value="6">모자</option>
            <option value="7">상의</option>
            <option value="8">한벌옷</option>
            <option value="9">하의</option>
            <option value="10">신발</option>
            <option value="11">장갑</option>
            <option value="12">망토</option>
            <option value="13">벨트</option>
            <option value="14">어깨장식</option>
            <option value="15">얼굴장식</option>
            <option value="16">눈장식</option>
            <option value="17">귀고리</option>
            <option value="18">반지</option>
            <option value="19">펜던트</option>
            <option value="20">기계심장</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>잠재능력 재설정 종류</label>
          <label><input type="radio" name="cubeKind" value="black" checked />윗잠재 (블랙큐브)</label>
          <label><input type="radio" name="cubeKind" value="meister" />명장의 큐브</label>
          <label><input type="radio" name="cubeKind" value="addi" />아랫잠재 (에디셔널 큐브)</label>
        </div>
        <div>
          <label>주스탯</label>
          <div>
            <label><input type="radio" name="mainStat" value="STR" checked />STR</label>
            <label><input type="radio" name="mainStat" value="DEX" />DEX</label>
            <label><input type="radio" name="mainStat" value="INT" />INT</label>
            <label><input type="radio" name="mainStat" value="LUK" />LUK</label>
            <label><input type="radio" name="mainStat" value="ALLSTAT" />올스탯 (제논 용)</label>
            <label><input type="radio" name="mainStat" value="ANY" />아무거나 (대장장이 용)</label>
          </div>
        </div>
      </div>

      <!-- 무기 전용 자동 돌리기 설정 UI -->
      <div id="weaponAutoContainer" style="margin-top:8px; display:none;">
        <!--
        <label style="margin-bottom:4px;">자동 돌리기 설정 (무기류/장신구/방어구)</label>
        <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
          무기류: 보공/방무/공마 조합 & 에디 공마% 합계, 장신구/방어구: 주스탯% 및 에디 유효옵션 자동 돌리기 제공<br>
        </div>
        -->

        <!-- 아랫잠재(에디) 설정: ATK/MATK% 합계 임계값 -->
        <div data-auto-kind="addi-weapon">
          <label style="margin-bottom:4px;">아랫잠재 자동 돌리기 (공격력 / 마력 %)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:4px;">
            공격력/마력 % 합계가 설정값 이상이면 자동으로 멈춥니다.
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <label for="weaponAutoTarget" style="margin:0; font-size:0.85rem;">목표 공마 %</label>
            <input type="number" id="weaponAutoTarget" value="21" min="0" max="39" style="max-width:80px;" />
          </div>
        </div>

        <!-- 아랫잠재(에디) 설정: 장신구/방어구 유효 옵션 줄 수 -->
        <div data-auto-kind="addi-stat" style="margin-top:10px;">
          <label style="margin-bottom:4px;">아랫잠재 자동 돌리기 (장신구/방어구)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
            유효 옵션: 주스탯%/주스탯/공격력·마력/크뎀/쿨감(-1초)/9레벨당 주스탯<br>
            올스탯 선택 시 2줄은 올스탯 1줄 이상, 2.5줄/3줄은 올스탯 2줄 이상<br>
          </div>
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <label for="additionalAutoLines" style="margin:0; font-size:0.85rem;">유효 옵션 줄 수</label>
            <select id="additionalAutoLines" style="max-width:110px;">
              <option value="2">2줄</option>
              <option value="2.5">2.5줄</option>
              <option value="3">3줄</option>
            </select>
          </div>
          <div id="additionalCooldownRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label style="margin:0; font-size:0.85rem;">
              <input type="checkbox" id="additionalCooldownRequired" />
              무조건 첫줄 쿨감
            </label>
          </div>
        </div>

        <!-- 윗잠재 설정: IED/Boss/ATK(MATK) 유효 조합 -->
        <div data-auto-kind="main" style="margin-top:10px;">
          <label style="margin-bottom:4px;">무보엠류 자동 돌리기 (유효 옵션 조합)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
            최대 조건을 넘지 않는 후보가 나오면 자동으로 멈춤 <br>
            예시1: 방무를 최대 1줄로 설정한다면, 유효 옵션은 '공공공', '공공방'<br>
            예시2: 방무를 최대 0줄, 보공을 최대 1줄로 설정한다면, 유효 옵션은 '공공공', '보공공'
          </div>

          <div style="display:flex; align-items:center; gap:8px; white-space:nowrap;">
            <div style="display:flex; align-items:center; gap:8px;">
              <label for="autoMainIED" style="margin:0; font-size:0.85rem;">최대 방무 몇 줄</label>
              <select id="autoMainIED" style="max-width:110px;">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
              </select>
            </div>

            <div id="autoMainBossRow" style="display:flex; align-items:center; gap:8px;">
              <label for="autoMainBossMin" style="margin:0; font-size:0.85rem;">최대 보공 몇 줄</label>
              <select id="autoMainBossMin" style="max-width:110px;"></select>
            </div>
          </div>
          <div style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label style="margin:0; font-size:0.85rem;">
              <input type="checkbox" id="autoMainSeekDeparture" />
              이탈 잠재 옵션 노리기
            </label>
            <span style="font-size:0.75rem; color:#a1a1aa;">
              2~3줄에 이탈옵 등장 시만 유효
            </span>
          </div>
        </div>

        <!-- 장신구/방어구 자동 돌리기: 주스탯% 합계 -->
        <div data-auto-kind="stat" style="margin-top:10px;">
          <label style="margin-bottom:4px;">장신구/방어구 자동 돌리기 (주스탯 %)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
            주스탯이 목표 이상이면 멈춥니다. "아무거나"는 4개 주스탯 중 가장 큰 합을 사용<br>
            "올스탯(제논 용)"은 STR/DEX/LUK을 각각 1/3 합산하며 올스탯%도 포함<br>
            쿨감/크뎀/드메는 설정된 주스탯 목표에 상관 없이, 더 높으면 유효옵 판정
          </div>

          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <label for="armorAutoTarget" style="margin:0; font-size:0.85rem;">목표 주스탯 %</label>
            <input type="number" id="armorAutoTarget" value="0" min="0" max="39" style="max-width:80px;" />
          </div>

          <div id="armorCooldownRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label for="armorCooldownMin" style="margin:0; font-size:0.85rem;">목표 최소 쿨감</label>
            <select id="armorCooldownMin" style="max-width:110px;">
              <option value="0">0초</option>
              <option value="1">1초</option>
              <option value="2">2초</option>
              <option value="3">3초</option>
              <option value="4">4초</option>
              <option value="5">5초</option>
              <option value="6">6초</option>
            </select>
          </div>

          <div id="armorCritRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label for="armorCritMin" style="margin:0; font-size:0.85rem;">목표 최소 크뎀 줄 수</label>
            <select id="armorCritMin" style="max-width:110px;">
              <option value="0">없음</option>
              <option value="1">크</option>
              <option value="2">크크</option>
              <option value="3">크크크</option>
            </select>
          </div>

          <div id="accessoryDropRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label for="accessoryDropMin" style="margin:0; font-size:0.85rem;">목표 드메 줄 수</label>
            <select id="accessoryDropMin" style="max-width:110px;">
              <option value="0">0줄</option>
              <option value="1">1줄</option>
              <option value="2">2줄</option>
            </select>
          </div>
        </div>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px;">
        <button class="btn btn-secondary" id="applyResetBtn" style="flex:1;">적용 및 리셋</button>
      </div>
      </section>

      <!-- 4. 로그 (토글 가능) -->
      <section class="card" id="card-log">
        <h2>
          <div class="log-header-row">
            <span>로그 (최근 100회)</span>
            <button type="button" id="toggleLogBtn" class="log-toggle-btn">펼치기</button>
          </div>
        </h2>
        <div id="log" style="display:none;"></div>
      </section>
    </div>

    <div class="layout-column">
      <!-- 2. 옵션 카드 + 재설정 버튼 -->
      <section class="card" id="card-options">
        <h2>잠재 옵션</h2>

      <div class="options-layout">
        <div class="option-box current" id="box-current">
          <div class="option-title">현재 옵션</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-current"></div>
          </div>
        </div>

        <div class="option-box candidate" id="box-roll1" data-choice="1">
          <div class="option-title">재설정 1</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-roll1"></div>
          </div>
        </div>
        <div class="option-box candidate" id="box-roll2" data-choice="2">
          <div class="option-title">재설정 2</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-roll2"></div>
          </div>
        </div>
        <div class="option-box candidate" id="box-roll3" data-choice="3">
          <div class="option-title">재설정 3</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-roll3"></div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px; display:flex; justify-content:flex-end; gap:8px; flex-wrap:wrap;">
        <!-- 자동 돌리기 시작/정지 버튼 -->
        <button class="btn btn-secondary" id="autoResetBtn">리셋</button>
        <button class="btn btn-secondary" id="autoRollBtn">자동 돌리기 시작</button>
        <button class="btn btn-primary" id="rollBtn">3회 재설정 하기</button>
      </div>
      </section>

      <!-- 3. 재설정 현황 -->
      <section class="card" id="card-stats">
        <h2>재설정 현황</h2>
        <div class="stats-row">
          <div id="rollCountTag">재설정 횟수: 0</div>
          <div id="mesoTag">소모 메소: 0 메소</div>
          <div id="azmosTag" style="display:none; color:#a1a1aa; font-size:0.85rem;">아즈모스 협곡 1만점: 0주</div>
          <div id="cubeTypeTag" class="tag">
            <span class="tag-dot"></span>
            <span>윗잠재</span>
          </div>
        </div>
      </section>
    </div>
  </div>

  <!-- 메인 로직 스크립트 -->
  <script>
    const LAST_UPDATE_DATE = "2026-02-02";
    const SETTINGS_STORAGE_KEY = "cubeSimLastSettings";

    // ====== Nexon Open API: 내 장비 불러오기 ======
    const NX_API_STORAGE_KEY = "MS_API_KEY_V1";
    const NX_BASE = "https://open.api.nexon.com/maplestory/v1";

    let useMyEquip = false;
    let nxEquipRaw = null;     // item-equipment raw response
    let nxEquipItems = [];     // normalized list for current preset
    let selectedEquipKey = "";

    const PART_TO_PARTSTYPE = {
      "무기": 1,
      "엠블렘": 2,
      "보조무기": 3,
      "포스실드": 4,
      "소울링": 4,
      "방패": 5,
      "모자": 6,
      "상의": 7,
      "한벌옷": 8,
      "하의": 9,
      "신발": 10,
      "장갑": 11,
      "망토": 12,
      "벨트": 13,
      "어깨장식": 14,
      "얼굴장식": 15,
      "눈장식": 16,
      "귀고리": 17,
      "반지": 18,
      "펜던트": 19,
      "기계심장": 20
    };

    function isLegendary(grade) {
      return grade === "레전드리";
    }

    function formatDateYYYYMMDD(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${day}`;
    }

    function getDefaultNxDate() {
      // Open API는 지연이 있을 수 있어 기본은 전일
      const d = new Date();
      d.setDate(d.getDate() - 1);
      return formatDateYYYYMMDD(d);
    }

    function setMyEquipStatus(text, isError=false) {
      const el = document.getElementById("myEquipStatus");
      if (!el) return;
      el.textContent = text || "";
      el.style.color = isError ? "#fca5a5" : "#a1a1aa";
    }

    function setControlsDisabledByMyEquipMode(disabled) {
      const itemLevel = document.getElementById("itemLevel");
      const partsType = document.getElementById("partsType");
      if (itemLevel) itemLevel.disabled = disabled;
      if (partsType) partsType.disabled = disabled;
    }

    function getSelectedCubeKind() {
      return document.querySelector('input[name="cubeKind"]:checked')?.value || "black";
    }

    function setCubeKind(kind) {
      const r = document.querySelector(`input[name="cubeKind"][value="${kind}"]`);
      if (r) r.checked = true;
      updateCubeTag();
    }

    function getSideFromCubeKind(kind) {
      return kind === "addi" ? "addi" : "main";
    }

    async function nxFetch(path, apiKey) {
      const res = await fetch(`${NX_BASE}${path}`, {
        headers: { "x-nxopen-api-key": apiKey }
      });
      if (!res.ok) {
        const t = await res.text().catch(() => "");
        throw new Error(`HTTP ${res.status} ${res.statusText}${t ? " - " + t : ""}`);
      }
      return res.json();
    }

    async function fetchOcidByName(name, apiKey) {
      const q = encodeURIComponent(name.trim());
      return nxFetch(`/id?character_name=${q}`, apiKey);
    }

    async function fetchItemEquipment(ocid, apiKey, dateStr) {
      const qOcid = encodeURIComponent(ocid);
      const qDate = encodeURIComponent(dateStr);
      return nxFetch(`/character/item-equipment?ocid=${qOcid}&date=${qDate}`, apiKey);
    }

    function normalizeNxEquipItems(raw, presetNo) {
      if (!raw) return [];
      const list = raw.item_equipment || [];
      const out = [];
      list.forEach((it, idx) => {
        // preset: item_equipment_preset_no 값이 있는 경우만 필터
        const pno = it.item_equipment_preset_no;
        if (presetNo && pno && String(pno) !== String(presetNo)) return;

        const partName = it.item_equipment_part || "";
        const partsType = PART_TO_PARTSTYPE[partName] ?? null;

        const mainGrade = it.potential_option_grade ?? null;
        const addGrade  = it.additional_potential_option_grade ?? null;

        const key = `${partName}|${it.item_name}|${it.item_equipment_slot || ""}|${idx}`;

        out.push({
          key,
          idx,
          item_name: it.item_name,
          partName,
          partsType,
          reqLev: it.item_base_option?.base_equipment_level ?? it.item_base_option?.base_req_level ?? it.item_description?.req_lev ?? it.item_equipment_req_level ?? it.item_equipment_level ?? it.item_equipment_req_lev ?? it.item_equipment_reqlev ?? it.item_req_lev ?? it.item_equipment_req ?? it.item_equipment_req_level ?? it.item_equipment_req_lev, // defensive
          // most reliable in your sample: item_equipment_req_level
          reqLev2: it.item_equipment_req_level,
          mainGrade,
          addGrade,
          mainLines: [it.potential_option_1, it.potential_option_2, it.potential_option_3].filter(Boolean),
          addLines: [it.additional_potential_option_1, it.additional_potential_option_2, it.additional_potential_option_3].filter(Boolean),
        });
      });

      // reqLev 정리: sample 기준 item_equipment_req_level 사용
      out.forEach(o => {
        const v = Number(o.reqLev2 ?? o.reqLev);
        o.reqLev = Number.isFinite(v) && v > 0 ? v : null;
      });

      return out;
    }

    function buildEquipOptionLabel(e) {
      const main = e.mainGrade ? `윗:${e.mainGrade}` : "윗:-";
      const add  = e.addGrade  ? `아랫:${e.addGrade}` : "아랫:-";
      const lv   = e.reqLev ? `Lv.${e.reqLev}` : "Lv.-";
      const part = e.partName || "?";
      const reason = (!isLegendary(e.mainGrade) && !isLegendary(e.addGrade)) ? " (레전더리 없음)" : "";
      return `[${part}] ${e.item_name} (${lv}) | ${main} / ${add}${reason}`;
    }

    function renderMyEquipSelect() {
      const sel = document.getElementById("myEquipSelect");
      if (!sel) return;
      sel.innerHTML = "";

      if (!nxEquipItems.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(선택 가능한 장비가 없습니다)";
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "(아이템을 선택하세요)";
      sel.appendChild(placeholder);

      nxEquipItems.forEach(e => {
        const opt = document.createElement("option");
        opt.value = e.key;
        opt.textContent = buildEquipOptionLabel(e);
        const enabled = isLegendary(e.mainGrade) || isLegendary(e.addGrade);
        if (!enabled) opt.disabled = true;
        sel.appendChild(opt);
      });

      sel.disabled = false;
    }

    function getSelectedNxEquip() {
      return nxEquipItems.find(e => e.key === selectedEquipKey) || null;
    }

    function updateMyEquipSideUI(equip) {
      const hint = document.getElementById("myEquipSideHint");

      if (!equip) {
        if (hint) hint.textContent = "";
        return;
      }

      const partsLabel = equip.partName || "-";
      const lvLabel = equip.reqLev ? `Lv.${equip.reqLev}` : "-";
      const info = `${partsLabel} / ${lvLabel} | 윗:${equip.mainGrade ?? "-"} / 아랫:${equip.addGrade ?? "-"}`;
      if (hint) hint.textContent = info;
    }

    function normalizeStatText(text) {
      return (text || "").replace(/\s+/g, "");
    }

    function detectMainStatFromLines(lines) {
      const counts = { STR: 0, DEX: 0, INT: 0, LUK: 0, ALLSTAT: 0 };
      if (!Array.isArray(lines)) return null;
      lines.forEach(line => {
        const text = normalizeStatText(line);
        if (!text) return;
        if (text.includes("올스탯")) counts.ALLSTAT += 1;
        if (text.includes("STR") || text.includes("힘")) counts.STR += 1;
        if (text.includes("DEX") || text.includes("민첩")) counts.DEX += 1;
        if (text.includes("INT") || text.includes("지력")) counts.INT += 1;
        if (text.includes("LUK") || text.includes("운")) counts.LUK += 1;
      });

      let max = 0;
      Object.values(counts).forEach(val => {
        if (val > max) max = val;
      });
      if (!max) return null;

      const winners = Object.entries(counts).filter(([, val]) => val === max);
      if (winners.length !== 1) return null;
      return winners[0][0];
    }

    function applyMainStatSelection(stat) {
      if (!stat) return;
      const radio = document.querySelector(`input[name="mainStat"][value="${stat}"]`);
      if (radio) {
        radio.checked = true;
        saveCurrentSettings();
      }
    }

    function isSideLegendary(equip, side) {
      if (!equip) return false;
      return side === "addi" ? isLegendary(equip.addGrade) : isLegendary(equip.mainGrade);
    }

    function ensureValidCubeKindForEquip(equip) {
      if (!equip) return;
      const currentKind = getSelectedCubeKind();
      const mainOk = isSideLegendary(equip, "main");
      const addOk = isSideLegendary(equip, "addi");

      if (currentKind === "addi") {
        if (!addOk && mainOk) {
          setCubeKind("black");
        }
      } else {
        if (!mainOk && addOk) {
          setCubeKind("addi");
        }
      }
    }

    function getEquipLinesForCubeKind(equip, cubeKind) {
      const side = getSideFromCubeKind(cubeKind);
      return side === "addi" ? equip.addLines : equip.mainLines;
    }

    function applyNxEquipToSimulator(equip) {
      if (!equip) return;

      if (!equip.partsType) {
        alert(`지원하지 않는 장비 부위입니다: ${equip.partName || "?"}`);
        return;
      }
      if (!equip.reqLev) {
        alert("아이템 레벨(제한)을 확인할 수 없습니다.");
        return;
      }

      // 레벨/부위 자동 설정 + lock
      const itemLevelSel = document.getElementById("itemLevel");
      const partsTypeSel = document.getElementById("partsType");

      // itemLevel 옵션에 없는 레벨이면 가장 가까운 상위(?)가 아니라 그대로는 불가능.
      // 현재 UI는 100/120/130/140/150/160/200/250만 지원하므로, 그 외 레벨은 가장 가까운 구간으로 매핑.
      const supported = [100,120,130,140,150,160,200,250];
      let mapped = equip.reqLev;
      if (!supported.includes(mapped)) {
        // 일반적으로 140/160/200/250 구간이므로, 가장 가까운 하한으로 snap
        mapped = supported.reduce((best, v) => (Math.abs(v - equip.reqLev) < Math.abs(best - equip.reqLev) ? v : best), supported[0]);
      }

      if (itemLevelSel) itemLevelSel.value = String(mapped);
      if (partsTypeSel) partsTypeSel.value = String(equip.partsType);

      // 표시
      const auto = document.getElementById("myEquipAutoPartLevel");
      if (auto) auto.textContent = `${equip.partName} / Lv.${equip.reqLev}`;

      // 큐브 종류 유효성 보정
      ensureValidCubeKindForEquip(equip);

      // 현재 옵션을 "내 장비 잠재"로 덮어쓰기
      const cubeKind = getSelectedCubeKind();
      const linesText = getEquipLinesForCubeKind(equip, cubeKind);
      const lines = [];
      for (let i = 0; i < 3; i++) {
        const t = linesText[i] || "-";
        lines.push({ line: i+1, optionText: t, raw: null });
      }
      currentLines = lines;
      rollCandidates = [[], [], []];

      // 통계 초기화 + 렌더
      meisterUsed = 0;
      mesoUsed = 0;
      rollCount = 0;
      logEntries = [];
      document.getElementById("log").textContent = "";
      updateCubeTag();
      updateStatsTags();
      renderAllBoxes();
      applyMainStatSelection(detectMainStatFromLines(linesText));
    }

    let bcProbs = [];
    let wcProbs = [];
    let acProbs = []; // 명장의 큐브(윗잠재)
    let allProbs = [];

    const CUBE_ID_BLACK = "5062010";   // 기존 윗잠재(블랙)
    const CUBE_ID_ADDI  = "5062500";   // 기존 에디
    const CUBE_ID_MEISTER = "2711004"; // acprobs.json 확인값

    let currentLines = [];
    let rollCandidates = [[], [], []];

    let meisterUsed = 0; // 명장의 큐브 소모량(개)
    let rollCount = 0;
    let mesoUsed = 0;
    let logEntries = [];

    let logVisible = false;

    const poolCache = new Map();

    const ONLY_ONE_KEYWORDS = [
      "쓸만한",
      "피격 후 무적"
    ];
    const AT_MOST_TWO_KEYWORDS = [
      "피격 시 일정 확률로 데미지",
      "피격 시 일정 확률로 일정 시간 무적"
    ];

    function getStoredSettings() {
      const raw = localStorage.getItem(SETTINGS_STORAGE_KEY);
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (err) {
        console.warn("저장된 설정을 읽지 못했습니다:", err);
        return null;
      }
    }

    function applyStoredSettings(settings) {
      if (!settings) return;

      const itemLevel = document.getElementById("itemLevel");
      if (itemLevel && settings.itemLevel) {
        itemLevel.value = String(settings.itemLevel);
      }

      const partsType = document.getElementById("partsType");
      if (partsType && settings.partsType) {
        partsType.value = String(settings.partsType);
      }

      if (settings.cubeKind) {
        const cubeRadio = document.querySelector(`input[name="cubeKind"][value="${settings.cubeKind}"]`);
        if (cubeRadio) cubeRadio.checked = true;
      }

      if (settings.mainStat) {
        const statRadio = document.querySelector(`input[name="mainStat"][value="${settings.mainStat}"]`);
        if (statRadio) statRadio.checked = true;
      }

      const weaponAutoTarget = document.getElementById("weaponAutoTarget");
      if (weaponAutoTarget && settings.weaponAutoTarget !== undefined) {
        weaponAutoTarget.value = String(settings.weaponAutoTarget);
      }

      const additionalAutoLines = document.getElementById("additionalAutoLines");
      if (additionalAutoLines && settings.additionalAutoLines) {
        additionalAutoLines.value = String(settings.additionalAutoLines);
      }

      const additionalCooldownRequired = document.getElementById("additionalCooldownRequired");
      if (additionalCooldownRequired && settings.additionalCooldownRequired !== undefined) {
        additionalCooldownRequired.checked = Boolean(settings.additionalCooldownRequired);
      }

      const autoMainIED = document.getElementById("autoMainIED");
      if (autoMainIED && settings.autoMainIED !== undefined) {
        autoMainIED.value = String(settings.autoMainIED);
      }

      const autoMainBossMin = document.getElementById("autoMainBossMin");
      if (autoMainBossMin && settings.autoMainBossMin !== undefined) {
        autoMainBossMin.value = String(settings.autoMainBossMin);
      }

      const autoMainSeekDeparture = document.getElementById("autoMainSeekDeparture");
      if (autoMainSeekDeparture && settings.autoMainSeekDeparture !== undefined) {
        autoMainSeekDeparture.checked = Boolean(settings.autoMainSeekDeparture);
      }

      const armorAutoTarget = document.getElementById("armorAutoTarget");
      if (armorAutoTarget && settings.armorAutoTarget !== undefined) {
        armorAutoTarget.value = String(settings.armorAutoTarget);
      }

      const armorCooldownMin = document.getElementById("armorCooldownMin");
      if (armorCooldownMin && settings.armorCooldownMin !== undefined) {
        armorCooldownMin.value = String(settings.armorCooldownMin);
      }

      const armorCritMin = document.getElementById("armorCritMin");
      if (armorCritMin && settings.armorCritMin !== undefined) {
        armorCritMin.value = String(settings.armorCritMin);
      }

      const accessoryDropMin = document.getElementById("accessoryDropMin");
      if (accessoryDropMin && settings.accessoryDropMin !== undefined) {
        accessoryDropMin.value = String(settings.accessoryDropMin);
      }
    }

    function saveCurrentSettings() {
      const cubeKind = document.querySelector('input[name="cubeKind"]:checked');
      const mainStat = document.querySelector('input[name="mainStat"]:checked');
      const payload = {
        itemLevel: Number(document.getElementById("itemLevel").value),
        partsType: Number(document.getElementById("partsType").value),
        cubeKind: cubeKind ? cubeKind.value : "black",
        mainStat: mainStat ? mainStat.value : "STR",
        weaponAutoTarget: Number(document.getElementById("weaponAutoTarget")?.value ?? 0),
        additionalAutoLines: document.getElementById("additionalAutoLines")?.value ?? "2",
        additionalCooldownRequired: Boolean(document.getElementById("additionalCooldownRequired")?.checked),
        autoMainIED: Number(document.getElementById("autoMainIED")?.value ?? 0),
        autoMainBossMin: Number(document.getElementById("autoMainBossMin")?.value ?? 0),
        autoMainSeekDeparture: Boolean(document.getElementById("autoMainSeekDeparture")?.checked),
        armorAutoTarget: Number(document.getElementById("armorAutoTarget")?.value ?? 0),
        armorCooldownMin: Number(document.getElementById("armorCooldownMin")?.value ?? 0),
        armorCritMin: Number(document.getElementById("armorCritMin")?.value ?? 0),
        accessoryDropMin: Number(document.getElementById("accessoryDropMin")?.value ?? 0)
      };
      localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(payload));
    }

    async function loadData() {
      const [bc, wc, ac] = await Promise.all([
        fetch("bcprobs.json").then(r => r.json()),
        fetch("wcprobs.json").then(r => r.json()),
        fetch("acprobs.json").then(r => r.json())
      ]);
      bcProbs = bc;
      wcProbs = wc;
      acProbs = ac;

      allProbs = [...bcProbs, ...wcProbs, ...acProbs]; // 핵심
      console.log("데이터 로드 완료:", allProbs.length);
      initCurrentOption();
    }

    function formatAzmosWeeksFromCubes(cubes) {
      const weeks = Math.ceil((cubes || 0) / 29); // 29개/주, 올림
      if (weeks <= 52) return `${weeks}주`;

      const years = Math.floor(weeks / 52);
      const rem = weeks % 52;
      if (rem === 0) return `${years}년`;
      return `${years}년 ${rem}주`;
    }


    function getSelectedLevel() {
      return Number(document.getElementById("itemLevel").value);
    }
    function getSelectedPartsType() {
      return Number(document.getElementById("partsType").value);
    }
    function getSelectedCubeId() {
      const kind = document.querySelector('input[name="cubeKind"]:checked').value;

      if (kind === "addi") return CUBE_ID_ADDI;
      if (kind === "meister") return CUBE_ID_MEISTER;

      // default: black
      return CUBE_ID_BLACK;
    }

    // 주스탯 getter (자동 스크립트에서 사용 예정)
    function getSelectedMainStat() {
      const r = document.querySelector('input[name="mainStat"]:checked');
      return r ? r.value : "STR";
    }

    function updateCubeTag() {
      const cubeId = getSelectedCubeId();
      const tag = document.getElementById("cubeTypeTag").querySelector("span:last-child");

      if (cubeId === CUBE_ID_ADDI) tag.textContent = "아랫잠재";
      else if (cubeId === CUBE_ID_MEISTER) tag.textContent = "명장의 큐브";
      else tag.textContent = "윗잠재";
    }


    function formatMesoKorean(v) {
    if (!v) return "0 메소";
    const isNegative = v < 0;
    let n = Math.abs(v);

    // ✅ 조 단위 추가 (10^12)
    const jo  = Math.floor(n / 1000000000000); // 1,000,000,000,000
    n = n % 1000000000000;

    const eok = Math.floor(n / 100000000);     // 1억
    n = n % 100000000;

    const man = Math.floor(n / 10000);         // 1만
    const one = n % 10000;

    const parts = [];
    if (jo)  parts.push(jo  + "조");
    if (eok) parts.push(eok + "억");
    if (man) parts.push(man + "만");
    if (one || parts.length === 0) parts.push(one.toLocaleString("ko-KR"));

    return (isNegative ? "-" : "") + parts.join(" ") + " 메소";
    }


    function updateStatsTags() {
      const cubeId = getSelectedCubeId();

      const rollCountEl = document.getElementById("rollCountTag");
      const mesoTag = document.getElementById("mesoTag");
      const azmosTag = document.getElementById("azmosTag");

      if (cubeId === CUBE_ID_MEISTER) {
        // ✅ 명장: 재설정 횟수는 숨김(소모 큐브로 충분)
        if (rollCountEl) rollCountEl.style.display = "none";

        if (mesoTag) mesoTag.textContent = `소모된 명장의 큐브: ${meisterUsed}개`;

        if (azmosTag) {
          azmosTag.style.display = "block";
          azmosTag.textContent = `아즈모스 협곡 1만점: ${formatAzmosWeeksFromCubes(meisterUsed)}`;
        }
        return;
      }

      // 블랙/에디: 재설정 횟수 표시 + 메소 표시
      if (rollCountEl) {
        rollCountEl.style.display = "block";
        rollCountEl.textContent = `재설정 횟수: ${rollCount}`;
      }

      if (mesoTag) mesoTag.textContent = `소모 메소: ${formatMesoKorean(mesoUsed)}`;
      if (azmosTag) azmosTag.style.display = "none";
    }



    function updateLogVisibility() {
      // 업데이트 날짜 표시
      const updateDateEl = document.getElementById("updateDate");
      if (updateDateEl) {
        updateDateEl.textContent = `업데이트: ${LAST_UPDATE_DATE}`;
      }

      const logDiv = document.getElementById("log");
      const btn = document.getElementById("toggleLogBtn");
      if (logVisible) {
        logDiv.style.display = "block";
        btn.textContent = "접기";
      } else {
        logDiv.style.display = "none";
        btn.textContent = "펼치기";
      }
    }

    function getCostPerSet(level, cubeItemID) {
      const isAddi = cubeItemID === "5062500";
      const tableMain = [
        {min:250, max:300, cost: 50000000},
        {min:200, max:249, cost: 45000000},
        {min:160, max:199, cost: 42500000},
        {min:1,   max:159, cost: 40000000}
      ];
      const tableAddi = [
        {min:250, max:300, cost: 98000000},
        {min:200, max:249, cost: 88000000},
        {min:160, max:199, cost: 83000000},
        {min:1,   max:159, cost: 78000000}
      ];
      const table = isAddi ? tableAddi : tableMain;
      for (const row of table) {
        if (level >= row.min && level <= row.max) return row.cost;
      }
      return table[table.length - 1].cost;
    }

    function poolKey(cubeItemID, partsType, level, line) {
      return `${cubeItemID}-${partsType}-${level}-${line}`;
    }

    function getBasePool(cubeItemID, partsType, level, line) {
      const key = poolKey(cubeItemID, partsType, level, line);
      if (poolCache.has(key)) return poolCache.get(key);
      const pool = allProbs.filter(
        r =>
          r.cubeItemID === cubeItemID &&
          r.partsType === partsType &&
          r.reqLev === level &&
          r.line === line
      );
      poolCache.set(key, pool);
      return pool;
    }

    function textMatchesAny(text, keywords) {
      return keywords.some(kw => text.includes(kw));
    }
    function isGroupOne(text) {
      return textMatchesAny(text, ONLY_ONE_KEYWORDS);
    }
    function isGroupTwo(text) {
      return textMatchesAny(text, AT_MOST_TWO_KEYWORDS);
    }

    function rollOneLine({cubeItemID, partsType, level, line, existingLines}) {
      const basePool = getBasePool(cubeItemID, partsType, level, line);
      if (!basePool.length) return null;

      const countG1 = existingLines.filter(l => isGroupOne(l.optionText)).length;
      const countG2 = existingLines.filter(l => isGroupTwo(l.optionText)).length;

      const filtered = [];
      for (const row of basePool) {
        const text = row.optionText;
        if (isGroupOne(text) && countG1 >= 1) continue;
        if (isGroupTwo(text) && countG2 >= 2) continue;
        filtered.push(row);
      }
      if (!filtered.length) return null;

      let totalProb = 0;
      for (const row of filtered) totalProb += row.probability;

      const r = Math.random() * totalProb;
      let acc = 0;
      for (const row of filtered) {
        acc += row.probability;
        if (r <= acc) {
          return { line, optionText: row.optionText, raw: row };
        }
      }
      const last = filtered[filtered.length - 1];
      return { line, optionText: last.optionText, raw: last };
    }

    function isSameSet(aLines, bLines) {
      if (!aLines || !bLines) return false;
      if (aLines.length !== 3 || bLines.length !== 3) return false;
      for (let i = 0; i < 3; i++) {
        if (aLines[i].optionText !== bLines[i].optionText) return false;
      }
      return true;
    }

    function rollOneSet(context) {
      // ====== (1) 사전검증: 해당 조합이 데이터에 존재하지 않으면 즉시 실패 ======
      // getBasePool은 cubeItemID/partsType/reqLev/line 완전 일치로 필터링하므로,
      // 존재하지 않는 조합이면 basePool이 비고 rollOneLine이 null을 반환한다. :contentReference[oaicite:4]{index=4}
      for (let line = 1; line <= 3; line++) {
        const base = getBasePool(context.cubeItemID, context.partsType, context.level, line);
        if (!base || base.length === 0) return null;
      }

      // ====== (2) 안전장치: 최대 시도 횟수 제한 (무한루프 방지) ======
      const MAX_ATTEMPTS = 5000;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const lines = [];
        for (let line = 1; line <= 3; line++) {
          const opt = rollOneLine({
            cubeItemID: context.cubeItemID,
            partsType: context.partsType,
            level: context.level,
            line,
            existingLines: lines
          });
          if (!opt) break;
          lines.push(opt);
        }
        if (lines.length !== 3) continue;
        if (isSameSet(lines, currentLines)) continue;
        return lines;
      }

      // 시도 횟수를 다 써도 3줄 세트를 못 만들면 실패로 간주
      return null;
    }


    function renderLines(elemId, lines) {
      const elem = document.getElementById(elemId);
      elem.innerHTML = "";
      if (!lines || !lines.length) {
        elem.innerHTML = "<div style='color:#71717a;'>-</div>";
        return;
      }
      for (const l of lines) {
        const div = document.createElement("div");
        div.textContent = l.optionText;
        elem.appendChild(div);
      }
    }

    function renderAllBoxes() {
      renderLines("lines-current", currentLines);
      renderLines("lines-roll1", rollCandidates[0]);
      renderLines("lines-roll2", rollCandidates[1]);
      renderLines("lines-roll3", rollCandidates[2]);
    }

    function appendLogEntry(text) {
      logEntries.unshift(text);
      if (logEntries.length > 100) logEntries.pop();
      document.getElementById("log").textContent = logEntries.join("\n");
    }

    function initCurrentOption() {
      const cubeItemID = getSelectedCubeId();
      const level = getSelectedLevel();
      const partsType = getSelectedPartsType();
      const ctx = { cubeItemID, partsType, level };

      const first = rollOneSet(ctx);
      if (!first) {
        // invalid 조합: 프리즈 대신 정상 실패 처리
        currentLines = [];
        rollCandidates = [[], [], []];
        rollCount = 0;
        mesoUsed = 0;
        meisterUsed = 0;
        logEntries = [];
        document.getElementById("log").textContent = "";
        updateCubeTag();
        updateStatsTags();
        renderAllBoxes();
        alert("선택한 레벨/부위 조합은 데이터가 없어 옵션을 생성할 수 없습니다. 다른 레벨을 선택하세요.");
        return;
      }

      currentLines = first;
      rollCandidates = [[], [], []];

      rollCount = 0;
      mesoUsed = 0;
      logEntries = [];
      document.getElementById("log").textContent = "";
      updateCubeTag();
      updateStatsTags();
      renderAllBoxes();
    }

    function doOneRollStep() {
      const cubeItemID = getSelectedCubeId();
      const level = getSelectedLevel();
      const partsType = getSelectedPartsType();
      const ctx = { cubeItemID, partsType, level };

      const cubeId = cubeItemID; // 의미상 동일. 기존 변수명 유지하고 싶으면 cubeId로 통일
      const costPerSet = (cubeId === CUBE_ID_MEISTER) ? 0 : getCostPerSet(level, cubeId);

      const cand1 = rollOneSet(ctx);
      const cand2 = rollOneSet(ctx);
      const cand3 = rollOneSet(ctx);

      if (!cand1 || !cand2 || !cand3) {
        rollCandidates = [[], [], []];
        renderAllBoxes();
        alert("선택한 레벨/부위 조합은 데이터가 없어 재설정할 수 없습니다. 다른 조합을 선택하세요.");
        return;
      }

      rollCandidates = [cand1, cand2, cand3];
      rollCount += 3;

      if (cubeId === CUBE_ID_MEISTER) meisterUsed += 3;
      else mesoUsed += costPerSet * 3;
      // 로그 포맷: 헤더 + 1/2/3 줄로 가독성 있게
      const cubeLabel = cubeItemID === "5062500" ? "에디" : "윗";
      const partLabel = document.getElementById("partsType").selectedOptions[0].text;
      const header = `[${rollCount - 2}~${rollCount}] LV${level} ${cubeLabel} ${partLabel}`;
      const line1 = `  1) ${cand1.map(l=>l.optionText).join(" | ")}`;
      const line2 = `  2) ${cand2.map(l=>l.optionText).join(" | ")}`;
      const line3 = `  3) ${cand3.map(l=>l.optionText).join(" | ")}`;
      appendLogEntry(`${header}\n${line1}\n${line2}\n${line3}`);

      updateStatsTags();
      renderAllBoxes();
      triggerCandidatesFadeIn();
    }

    function triggerCandidatesFadeIn() {
      const ids = ["box-roll1", "box-roll2", "box-roll3"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        el.classList.remove("fade-in-fast");
        void el.offsetWidth;
        el.classList.add("fade-in-fast");
        el.addEventListener("animationend", () => {
          el.classList.remove("fade-in-fast");
        }, { once:true });
      });
    }

    function chooseCandidate(idx) {
      const cand = rollCandidates[idx];
      if (!cand || !cand.length) return;

      const boxId = `box-roll${idx + 1}`;
      const candBox = document.getElementById(boxId);
      const currentBox = document.getElementById("box-current");

      candBox.classList.remove("fade-out-card");
      void candBox.offsetWidth;
      candBox.classList.add("fade-out-card");

      candBox.addEventListener("animationend", () => {
        candBox.classList.remove("fade-out-card");

        currentLines = cand.map(l => ({...l}));
        renderAllBoxes();

        currentBox.classList.remove("fade-in-card");
        void currentBox.offsetWidth;
        currentBox.classList.add("fade-in-card");
        currentBox.addEventListener("animationend", () => {
          currentBox.classList.remove("fade-in-card");
        }, { once:true });
      }, { once:true });
    }

    // ============= 이벤트 바인딩 =============
    function handleReset() {
      meisterUsed = 0;
      mesoUsed = 0;
      rollCount = 0;
      initCurrentOption();
    }

    document.getElementById("applyResetBtn").addEventListener("click", handleReset);
    document.getElementById("autoResetBtn").addEventListener("click", handleReset);


    document.getElementById("rollBtn").addEventListener("click", () => {
      doOneRollStep();
    });

    document.querySelectorAll(".option-box.candidate").forEach(box => {
      box.addEventListener("click", (e) => {
        const idx = Number(e.currentTarget.getAttribute("data-choice")) - 1;
        chooseCandidate(idx);
      });
    });

    document.querySelectorAll('input[name="cubeKind"]').forEach(r => {
      r.addEventListener("change", () => {
        // 큐브 타입 변경 시 통계 초기화
        meisterUsed = 0;
        mesoUsed = 0;
        rollCount = 0;

        updateCubeTag();
        const eq = useMyEquip ? getSelectedNxEquip() : null;
        if (eq) {
          ensureValidCubeKindForEquip(eq);
          applyNxEquipToSimulator(eq);
        } else {
          initCurrentOption();
        }
        saveCurrentSettings();
      });
    });


    document.getElementById("itemLevel").addEventListener("change", () => {
      initCurrentOption();
      saveCurrentSettings();
    });
    document.getElementById("partsType").addEventListener("change", () => {
      initCurrentOption();
      saveCurrentSettings();
    });

    document.querySelectorAll('input[name="mainStat"]').forEach(r => {
      r.addEventListener("change", () => {
        saveCurrentSettings();
      });
    });

    [
      "weaponAutoTarget",
      "additionalAutoLines",
      "additionalCooldownRequired",
      "autoMainIED",
      "autoMainBossMin",
      "autoMainSeekDeparture",
      "armorAutoTarget",
      "armorCooldownMin",
      "armorCritMin",
      "accessoryDropMin"
    ].forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      const evt = el.type === "number" || el.tagName === "INPUT" ? "input" : "change";
      el.addEventListener(evt, () => {
        saveCurrentSettings();
      });
      if (el.tagName === "SELECT" || el.type === "checkbox") {
        el.addEventListener("change", () => {
          saveCurrentSettings();
        });
      }
    });

    document.getElementById("toggleLogBtn").addEventListener("click", () => {
      logVisible = !logVisible;
      updateLogVisibility();
    });

    
    // ====== 내 장비 불러오기 UI 바인딩 ======
    function initMyEquipUI() {
      const toggle = document.getElementById("useMyEquipToggle");
      const panel = document.getElementById("myEquipPanel");
      const apiInput = document.getElementById("nxApiKey");
      const clearBtn = document.getElementById("clearApiKeyBtn");
      const nameInput = document.getElementById("characterName");
      const fetchBtn = document.getElementById("fetchMyEquipBtn");
      const presetSel = document.getElementById("equipPreset");
      const equipSel = document.getElementById("myEquipSelect");

      // load saved api key
      const savedKey = localStorage.getItem(NX_API_STORAGE_KEY);
      if (savedKey && apiInput) apiInput.value = savedKey;

      function setPanelVisible(v) {
        if (panel) panel.style.display = v ? "block" : "none";
      }

      function setMode(v) {
        useMyEquip = v;
        setPanelVisible(v);
        if (!v) {
          // release lock and reset UI
          setControlsDisabledByMyEquipMode(false);
          nxEquipRaw = null;
          nxEquipItems = [];
          selectedEquipKey = "";
          const auto = document.getElementById("myEquipAutoPartLevel");
          if (auto) auto.textContent = "-";
          updateMyEquipSideUI(null);
          if (equipSel) {
            equipSel.innerHTML = "<option value=''> (먼저 장비를 불러오세요) </option>";
            equipSel.disabled = true;
          }
          setMyEquipStatus("");
          // 기존 동작으로 복귀: 현재 설정값 기반 재초기화
          initCurrentOption();
        }
      }

      if (toggle) {
        toggle.addEventListener("change", () => {
          setMode(toggle.checked);
        });
      }

      if (clearBtn) {
        clearBtn.addEventListener("click", () => {
          localStorage.removeItem(NX_API_STORAGE_KEY);
          if (apiInput) apiInput.value = "";
          setMyEquipStatus("저장된 키를 삭제했습니다.");
        });
      }

      async function doFetchEquip() {
        const apiKey = (apiInput?.value || "").trim();
        const name = (nameInput?.value || "").trim();
        if (!apiKey) { alert("API Key를 입력하세요."); return; }
        if (!name) { alert("닉네임을 입력하세요."); return; }

        setMyEquipStatus("OCID 조회 중...");
        fetchBtn.disabled = true;

        try {
          const ocidRes = await fetchOcidByName(name, apiKey);
          const ocid = ocidRes?.ocid;
          if (!ocid) throw new Error("OCID를 찾지 못했습니다.");

          const dateStr = getDefaultNxDate();
          setMyEquipStatus(`장비 조회 중... (기준일자: ${dateStr})`);
          const equipRes = await fetchItemEquipment(ocid, apiKey, dateStr);
          nxEquipRaw = equipRes;

          // 저장(성공 시)
          localStorage.setItem(NX_API_STORAGE_KEY, apiKey);

          // preset 반영
          const presetNo = presetSel?.value || "1";
          nxEquipItems = normalizeNxEquipItems(nxEquipRaw, presetNo);

          // item_equipment_preset_# 값이 없는 응답이면 위 필터로 다 비게 될 수 있으니 fallback
          if (!nxEquipItems.length) {
            nxEquipItems = normalizeNxEquipItems(nxEquipRaw, null);
          }

          renderMyEquipSelect();
          setMyEquipStatus(`불러오기 완료: ${nxEquipItems.length}개 장비`);

          // my mode에서 레벨/부위 선택 잠그기(아이템 선택 후)
          setControlsDisabledByMyEquipMode(true);

          // 프리셋 변경 시 아이템 재구성
        } catch (err) {
          console.error(err);
          setMyEquipStatus(`불러오기 실패: ${err.message}`, true);
          alert(`불러오기 실패: ${err.message}`);
        } finally {
          fetchBtn.disabled = false;
        }
      }

      if (fetchBtn) fetchBtn.addEventListener("click", doFetchEquip);

      if (presetSel) {
        presetSel.addEventListener("change", () => {
          if (!nxEquipRaw) return;
          const presetNo = presetSel.value;
          nxEquipItems = normalizeNxEquipItems(nxEquipRaw, presetNo);
          if (!nxEquipItems.length) nxEquipItems = normalizeNxEquipItems(nxEquipRaw, null);
          selectedEquipKey = "";
          renderMyEquipSelect();
          updateMyEquipSideUI(null);
        });
      }

      if (equipSel) {
        equipSel.addEventListener("change", () => {
          selectedEquipKey = equipSel.value;
          const eq = getSelectedNxEquip();
          updateMyEquipSideUI(eq);

          if (!eq) return;

          // 기본 side가 레전더리인지 확인 후 적용
          ensureValidCubeKindForEquip(eq);
          applyNxEquipToSimulator(eq);
        });
      }

      // 초기 토글 상태
      setPanelVisible(false);
    }

const storedSettings = getStoredSettings();
    applyStoredSettings(storedSettings);
    updateCubeTag();
    updateLogVisibility();
    initMyEquipUI();

    // ====== 업데이트 내역 토글 ======
    window.addEventListener("load", () => {
      const box = document.getElementById("changelog");
      const btn = document.getElementById("toggleChangelogBtn");
      if (!box || !btn) return;

      let changelogVisible = false;

      function updateChangelogVisibility() {
        box.style.display = changelogVisible ? "block" : "none";
        btn.textContent = changelogVisible ? "업데이트 내역 접기" : "업데이트 내역 보기";
      }

      btn.addEventListener("click", () => {
        changelogVisible = !changelogVisible;
        updateChangelogVisibility();
      });

      updateChangelogVisibility(); // 초기 상태 반영
    });


    loadData().catch(err => {
      console.error("데이터 로드 실패:", err);
      alert("bcprobs.json / wcprobs.json을 불러오지 못했습니다. 파일 위치를 확인하세요.");
    });
  </script>

  <!-- 자동 돌리기 전용 스크립트 (별도 파일) -->
  <script src="autoRoll.js"></script>
  <footer style="margin-top:18px; color:#71717a; font-size:0.75rem; text-align:center;">
    <!-- <div>제작: 크로아 - 윈메롱</div> -->
  
    <div style="margin-top:6px;">
      <button type="button" id="toggleChangelogBtn"
        style="border-radius:999px; border:1px solid #3f3f46; background:#111111; color:#e5e7eb; font-size:0.75rem; padding:2px 10px; cursor:pointer;">
        업데이트 내역 보기
      </button>
    </div>
  
    <div id="changelog"
     style="display:none;
            margin:12px auto 0;
            max-width:900px;
            text-align:left;
            padding:12px 14px;
            background:#111111;
            border-radius:10px;
            border:1px solid #27272a;
            white-space:normal;
            color:#e5e7eb;
            font-size:0.9rem;
            line-height:1.35;">

      <!-- 아래에 업데이트 내역을 계속 쌓아가면 됩니다 -->
      <div style="margin-bottom:10px;">
        <div style="color:#e5e7eb; font-weight:600;">2026-02-02</div>
        <div>- 에디 자동돌리기 조건 수정</div>
        <div>- 마지막으로 사용한 설정 저장 기능 추가 </div>
        <div style="color:#e5e7eb; font-weight:600;">2026-01-17</div>
        <div>- 자동돌리기 옆 리셋 버튼 추가</div>
        <div>- PC버전 ui 배치 수정</div>
        <div>- 무보엠 이탈옵션 저격 옵션 추가 및 조건 설정 옵션 변경</div>
        <div style="color:#e5e7eb; font-weight:600;">2026-01-02</div>
        <div>- 방어구/장신구 윗잠재 자동 돌리기 기능 추가</div>
        <div>- 방어구/장신구 아랫랫잠재 자동 돌리기 기능 추가</div>
        <div>- 제논 올스탯 자동돌리기 지원원</div>
        <div style="color:#e5e7eb; font-weight:600;">2025-12-30</div>
        <div>- 명장의 큐브 선택 가능, 아즈모스 협곡 1만점 기준으로 필요기간 표시</div>
        <div>- 자동돌리기 목표 옵션이 등장했을 때, 특수 효과 추가</div>
        <div>- 방패, 소울링/포스실드 자동 돌리기 지원</div>
        <div>- 현재 존재하지 않는 레벨과 장비 조합을 선택했을 때 페이지가 프리징되는 버그 수정</div>
        <div style="color:#e5e7eb; font-weight:600;">2025-12-26</div>
        <div>- 무보엠 윗잠 자동 돌리기 기능 추가</div>
        <div style="color:#e5e7eb; font-weight:600;">2025-11-27</div>
        <div>- 3번 돌리기 기능만 탑재하여 github 업로드</div>
      </div>
    </div>
  </footer>  
</body>
</html>
