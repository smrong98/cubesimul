<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>잠재능력 재설정 시뮬레이터</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background:#121212;
      color:#e5e7eb;
      margin:0;
      padding:16px;
    }
    h1 {
      margin:0 0 12px;
      font-size:1.4rem;
      color:#8CAF0B;
    }

    .layout {
      display:grid;
      grid-template-columns: minmax(280px, 340px) minmax(320px, 1fr);
      gap:16px;
      align-items:start;
    }
    @media (max-width: 768px) {
      .layout {
        display:flex;
        flex-direction:column;
      }
    }

    .card {
      background:#1e1e1e;
      border:1px solid #2d2d2d;
      border-radius:12px;
      padding:12px 14px;
      box-shadow:0 10px 30px rgba(0,0,0,0.6);
    }
    .card h2 {
      margin:0 0 8px;
      font-size:1rem;
      border-bottom:1px solid #2d2d2d;
      padding-bottom:4px;
      color:#ffffff;
    }
    @media (max-width: 768px) {
      .card {
        width:100%;
      }
    }

    label {
      font-size:0.85rem;
      display:block;
      margin-bottom:4px;
    }
    input[type="number"],
    select {
      width:100%;
      padding:6px 8px;
      border-radius:8px;
      border:1px solid #3f3f46;
      background:#111111;
      color:#e5e7eb;
      font-size:0.9rem;
    }
    input[type="radio"] {
      transform:translateY(1px);
      margin-right:4px;
    }
    .row {
      display:flex;
      gap:8px;
      margin-bottom:8px;
    }
    .row > div { flex:1; }

    .btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 12px;
      border-radius:999px;
      border:none;
      cursor:pointer;
      font-size:0.9rem;
      font-weight:600;
      transition:transform 0.06s ease, box-shadow 0.06s ease, background 0.1s;
      white-space:nowrap;
    }
    .btn-primary {
      background:linear-gradient(135deg,#8CAF0B,#a9d51a);
      color:#111827;
      box-shadow:0 10px 25px rgba(140,175,11,0.45);
    }
    .btn-primary:active {
      transform:translateY(1px) scale(.99);
      box-shadow:0 4px 12px rgba(140,175,11,0.35);
    }
    .btn-secondary {
      background:#27272a;
      color:#e5e7eb;
      border:1px solid #3f3f46;
    }
    .btn-secondary:active {
      transform:translateY(1px) scale(.99);
      box-shadow:0 4px 12px rgba(0,0,0,0.7);
    }

    .options-layout {
      margin-top:8px;
      display:grid;
      grid-template-columns:repeat(3, minmax(0,1fr));
      grid-auto-rows:auto;
      gap:8px;
      align-items:start;
    }
    #box-current {
      grid-column:2 / 3;
      grid-row:1;
    }
    #box-roll1 {
      grid-column:1 / 2;
      grid-row:2;
    }
    #box-roll2 {
      grid-column:2 / 3;
      grid-row:2;
    }
    #box-roll3 {
      grid-column:3 / 4;
      grid-row:2;
    }
    @media (max-width: 640px) {
      .options-layout {
        display:flex;
        flex-direction:column;
      }
      #box-current,
      #box-roll1,
      #box-roll2,
      #box-roll3 {
        grid-column:auto;
        grid-row:auto;
      }
    }

    .option-box {
      width:100%;
      min-height:120px;
      border-radius:12px;
      border:1px solid #303030;
      background:radial-gradient(circle at top, #252525 0, #111111 60%);
      font-size:0.8rem;
      position:relative;
      overflow:hidden;
      box-shadow:0 6px 18px rgba(0,0,0,0.55);
      transition:transform 0.08s ease, box-shadow 0.08s ease, border-color 0.08s ease;
      opacity:1;
    }
    .option-box.current {
      border-color:#8CAF0B;
      box-shadow:0 0 0 1px rgba(140,175,11,0.4), 0 6px 18px rgba(0,0,0,0.7);
    }

    .option-title {
      margin:-1px -1px 6px -1px;
      padding:4px 10px;
      background:linear-gradient(180deg, #8CAF0B, #5f7a07);
      border-radius:10px 10px 0 0;
      border-bottom:1px solid #141414;
      font-size:0.75rem;
      font-weight:600;
      color:#f9fafb;
      text-align:center;
      text-shadow:0 1px 1px rgba(0,0,0,0.7);
    }

    .option-inner {
      padding:4px 8px 8px;
    }

    .option-lines div {
      margin-bottom:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .option-box.candidate {
      cursor:pointer;
    }
    .option-box.candidate:hover {
      transform:translateY(-1px);
      box-shadow:0 10px 24px rgba(0,0,0,0.75);
      border-color:#8CAF0B;
    }
    .option-box.candidate:active {
      transform:translateY(0);
      box-shadow:0 6px 16px rgba(0,0,0,0.7);
    }

    /* 자동돌리기 성공 하이라이트: 테두리는 그대로 두고, 바깥으로 퍼지는 골드 글로우 */
    .option-box.auto-hit {
      box-shadow:
        0 0 14px rgba(255,225,130,0.45),   /* 중심 밝기 ↑ */
        0 0 30px rgba(255,210,110,0.32),
        0 0 60px rgba(255,210,110,0.22),
        0 0 90px rgba(255,210,110,0.12),
        0 10px 24px rgba(0,0,0,0.75);
    }


    /* 번쩍 효과(짧게): 글로우 강도만 순간적으로 올렸다가 내려감 */
    @keyframes autoHitFlash {
      0% {
        box-shadow:
          0 0 14px rgba(255,215,120,0.25),
          0 0 30px rgba(255,215,120,0.18),
          0 0 60px rgba(255,215,120,0.10),
          0 10px 24px rgba(0,0,0,0.75);
      }
      45% {
        box-shadow:
          0 0 22px rgba(255,235,150,0.85),  /* 핵심 */
          0 0 44px rgba(255,220,130,0.55),
          0 0 80px rgba(255,220,130,0.35),
          0 0 120px rgba(255,220,130,0.20),
          0 10px 24px rgba(0,0,0,0.75);
      }
      100% {
        box-shadow:
          0 0 14px rgba(255,215,120,0.45),
          0 0 30px rgba(255,215,120,0.32),
          0 0 60px rgba(255,215,120,0.22),
          0 10px 24px rgba(0,0,0,0.75);
      }
    }


    .option-box.auto-hit-flash {
      animation: autoHitFlash 0.9s ease-out;
    }



    @keyframes fadeInFast {
      from { opacity:0; transform:translateY(4px); }
      to   { opacity:1; transform:translateY(0); }
    }
    .fade-in-fast {
      animation:fadeInFast 0.18s ease-out;
    }

    @keyframes fadeOutCard {
      from { opacity:1; transform:scale(1); }
      to   { opacity:0; transform:scale(0.98); }
    }
    .fade-out-card {
      animation:fadeOutCard 0.15s ease-out;
    }
    @keyframes fadeInCard {
      from { opacity:0; transform:translateY(-2px); }
      to   { opacity:1; transform:translateY(0); }
    }
    .fade-in-card {
      animation:fadeInCard 0.2s ease-out;
    }

    .stats-row {
      margin-top:6px;
      font-size:0.9rem;
      display:flex;
      flex-direction:column;
      gap:4px;
    }

    #log {
      font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,"Liberation Mono","Courier New", monospace;
      font-size:0.75rem;
      max-height:260px;
      overflow-y:auto;
      padding:6px 8px;
      background:#111111;
      border-radius:8px;
      border:1px solid #27272a;
      white-space:pre-wrap;
    }

    .tag {
      display:inline-flex;
      align-items:center;
      gap:4px;
      font-size:0.75rem;
      padding:2px 6px;
      border-radius:999px;
      border:1px solid #3f3f46;
      background:#111111;
      margin-top:4px;
      width:max-content;
    }
    .tag-dot {
      width:6px;
      height:6px;
      border-radius:999px;
      background:#8CAF0B;
    }

    .log-header-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    .log-header-row span {
      font-size:1rem;
    }
    .log-toggle-btn {
      border-radius:999px;
      border:1px solid #3f3f46;
      background:#111111;
      color:#e5e7eb;
      font-size:0.75rem;
      padding:2px 8px;
      cursor:pointer;
    }
    .log-toggle-btn:hover {
      background:#1f1f1f;
    }

    #card-settings   { grid-column:1; grid-row:1; }
    #card-options    { grid-column:2; grid-row:1; }
    #card-stats      { grid-column:1; grid-row:2; }
    #card-log        { grid-column:2; grid-row:2; }
    @media (max-width: 768px) {
      #card-settings,
      #card-options,
      #card-stats,
      #card-log {
        grid-column:auto;
        grid-row:auto;
      }
    }
  </style>
</head>
<body>
  <h1>잠재능력 재설정 시뮬레이터</h1>
  <div id="updateDate"
  style="margin-top:2px; margin-bottom:14px; font-size:0.85rem; color:#a1a1aa; line-height:1.2;">
  </div>

  <div class="layout">
    <!-- 1. 설정 카드 -->
    <section class="card" id="card-settings">
      <h2>설정</h2>

      <div class="row">
        <div>
          <label for="itemLevel">아이템 레벨</label>
          <select id="itemLevel">
            <option value="100">100</option>
            <option value="120">120</option>
            <option value="130">130</option>
            <option value="140">140</option>
            <option value="150">150</option>
            <option value="160">160</option>
            <option value="200" selected>200</option>
            <option value="250">250</option>
          </select>
        </div>
        <div>
          <label for="partsType">장비 부위</label>
          <select id="partsType">
            <option value="1">무기</option>
            <option value="2">엠블렘</option>
            <option value="3">보조무기(포스실드 제외)</option>
            <option value="4">포스실드/소울링</option>
            <option value="5">방패</option>
            <option value="6">모자</option>
            <option value="7">상의</option>
            <option value="8">한벌옷</option>
            <option value="9">하의</option>
            <option value="10">신발</option>
            <option value="11">장갑</option>
            <option value="12">망토</option>
            <option value="13">벨트</option>
            <option value="14">어깨장식</option>
            <option value="15">얼굴장식</option>
            <option value="16">눈장식</option>
            <option value="17">귀고리</option>
            <option value="18">반지</option>
            <option value="19">펜던트</option>
            <option value="20">기계심장</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>잠재능력 재설정 종류</label>
          <label><input type="radio" name="cubeKind" value="black" checked />윗잠재 (블랙큐브)</label>
          <label><input type="radio" name="cubeKind" value="meister" />명장의 큐브</label>
          <label><input type="radio" name="cubeKind" value="addi" />아랫잠재 (에디셔널 큐브)</label>
        </div>
        <div>
          <label>주스탯</label>
          <div>
            <label><input type="radio" name="mainStat" value="STR" checked />STR</label>
            <label><input type="radio" name="mainStat" value="DEX" />DEX</label>
            <label><input type="radio" name="mainStat" value="INT" />INT</label>
            <label><input type="radio" name="mainStat" value="LUK" />LUK</label>
            <label><input type="radio" name="mainStat" value="ALLSTAT" />올스탯 (제논 용)</label>
            <label><input type="radio" name="mainStat" value="ANY" />아무거나 (대장장이 용)</label>
          </div>
        </div>
      </div>

      <!-- 무기 전용 자동 돌리기 설정 UI -->
      <div id="weaponAutoContainer" style="margin-top:8px; display:none;">
        <label style="margin-bottom:4px;">자동 돌리기 설정 (무기류/장신구/방어구)</label>
        <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
          무기류: 보공/방무/공마 조합 & 에디 공마% 합계, 장신구/방어구: 주스탯% 및 에디 유효옵션 자동 돌리기 제공<br>
        </div>

        <!-- 아랫잠재(에디) 설정: ATK/MATK% 합계 임계값 -->
        <div data-auto-kind="addi-weapon">
          <label style="margin-bottom:4px;">아랫잠재 자동 돌리기 (공격력 / 마력 %)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:4px;">
            공격력/마력 % 합계가 설정값 이상이면 자동으로 멈춥니다.
          </div>
          <div style="display:flex; align-items:center; gap:8px;">
            <label for="weaponAutoTarget" style="margin:0; font-size:0.85rem;">목표 공마 %</label>
            <input type="number" id="weaponAutoTarget" value="21" min="0" max="39" style="max-width:80px;" />
          </div>
        </div>

        <!-- 아랫잠재(에디) 설정: 장신구/방어구 유효 옵션 줄 수 -->
        <div data-auto-kind="addi-stat" style="margin-top:10px;">
          <label style="margin-bottom:4px;">아랫잠재 자동 돌리기 (장신구/방어구)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
            유효 옵션: 주스탯%/주스탯/공격력·마력/크뎀/쿨감(-1초)/9레벨당 주스탯<br>
            2줄 또는 3줄 만족 유효옵션으로 취급 (올스탯 선택 시 2줄은 올스탯 1줄 이상, 3줄은 올스탯 2줄 이상)
          </div>
          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <label for="additionalAutoLines" style="margin:0; font-size:0.85rem;">유효 옵션 줄 수</label>
            <select id="additionalAutoLines" style="max-width:110px;">
              <option value="2">2줄</option>
              <option value="3">3줄</option>
            </select>
          </div>
        </div>

        <!-- 윗잠재 설정: IED/Boss/ATK(MATK) 유효 조합 -->
        <div data-auto-kind="main" style="margin-top:10px;">
          <label style="margin-bottom:4px;">무보엠류 자동 돌리기 (유효 옵션 조합)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
            최소 조건을 만족하는 후보가 나오면 자동으로 멈춤 <br>
            예시1: 방무를 최대 1줄로 설정한다면, 유효 옵션은 '공공공', '공공방'<br>
            예시2: 방무를 최대 0줄, 보공을 최대 1줄로 설정한다면, 유효 옵션은 '공공공', '보공공'
          </div>

          <div style="display:flex; align-items:center; gap:8px; white-space:nowrap;">
            <div style="display:flex; align-items:center; gap:8px;">
              <label for="autoMainIED" style="margin:0; font-size:0.85rem;">최대 방무 몇 줄</label>
              <select id="autoMainIED" style="max-width:110px;">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
              </select>
            </div>

            <div id="autoMainBossRow" style="display:flex; align-items:center; gap:8px;">
              <label for="autoMainBossMin" style="margin:0; font-size:0.85rem;">최소 보공 몇 줄</label>
              <select id="autoMainBossMin" style="max-width:110px;"></select>
            </div>
          </div>
        </div>

        <!-- 장신구/방어구 자동 돌리기: 주스탯% 합계 -->
        <div data-auto-kind="stat" style="margin-top:10px;">
          <label style="margin-bottom:4px;">장신구/방어구 자동 돌리기 (주스탯 %)</label>
          <div style="font-size:0.8rem; color:#a1a1aa; margin-bottom:6px;">
            주스탯이 목표 이상이면 멈춥니다. "아무거나"는 4개 주스탯 중 가장 큰 합을 사용<br>
            "올스탯(제논 용)"은 STR/DEX/LUK을 각각 1/3 합산하며 올스탯%도 포함<br>
            쿨감/크뎀/드메는 설정된 주스탯 목표에 상관 없이, 더 높으면 유효옵 판정
          </div>

          <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
            <label for="armorAutoTarget" style="margin:0; font-size:0.85rem;">목표 주스탯 %</label>
            <input type="number" id="armorAutoTarget" value="0" min="0" max="39" style="max-width:80px;" />
          </div>

          <div id="armorCooldownRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label for="armorCooldownMin" style="margin:0; font-size:0.85rem;">목표 최소 쿨감</label>
            <select id="armorCooldownMin" style="max-width:110px;">
              <option value="0">0초</option>
              <option value="1">1초</option>
              <option value="2">2초</option>
              <option value="3">3초</option>
              <option value="4">4초</option>
              <option value="5">5초</option>
              <option value="6">6초</option>
            </select>
          </div>

          <div id="armorCritRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label for="armorCritMin" style="margin:0; font-size:0.85rem;">목표 최소 크뎀 줄 수</label>
            <select id="armorCritMin" style="max-width:110px;">
              <option value="0">없음</option>
              <option value="1">크</option>
              <option value="2">크크</option>
              <option value="3">크크크</option>
            </select>
          </div>

          <div id="accessoryDropRow" style="display:flex; align-items:center; gap:8px; margin-top:8px; flex-wrap:wrap;">
            <label for="accessoryDropMin" style="margin:0; font-size:0.85rem;">목표 드메 줄 수</label>
            <select id="accessoryDropMin" style="max-width:110px;">
              <option value="0">0줄</option>
              <option value="1">1줄</option>
              <option value="2">2줄</option>
            </select>
          </div>
        </div>
      </div>

      <div style="margin-top:10px; display:flex; gap:8px;">
        <button class="btn btn-secondary" id="applyResetBtn" style="flex:1;">적용 및 리셋</button>
      </div>
    </section>

    <!-- 2. 옵션 카드 + 재설정 버튼 -->
    <section class="card" id="card-options">
      <h2>잠재 옵션</h2>

      <div class="options-layout">
        <div class="option-box current" id="box-current">
          <div class="option-title">현재 옵션</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-current"></div>
          </div>
        </div>

        <div class="option-box candidate" id="box-roll1" data-choice="1">
          <div class="option-title">재설정 1</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-roll1"></div>
          </div>
        </div>
        <div class="option-box candidate" id="box-roll2" data-choice="2">
          <div class="option-title">재설정 2</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-roll2"></div>
          </div>
        </div>
        <div class="option-box candidate" id="box-roll3" data-choice="3">
          <div class="option-title">재설정 3</div>
          <div class="option-inner">
            <div class="option-lines" id="lines-roll3"></div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px; display:flex; justify-content:flex-end; gap:8px; flex-wrap:wrap;">
        <!-- 자동 돌리기 시작/정지 버튼 -->
        <button class="btn btn-secondary" id="autoRollBtn">자동 돌리기 시작</button>
        <button class="btn btn-primary" id="rollBtn">3회 재설정 하기</button>
      </div>
    </section>

    <!-- 3. 재설정 현황 -->
    <section class="card" id="card-stats">
      <h2>재설정 현황</h2>
      <div class="stats-row">
        <div id="rollCountTag">재설정 횟수: 0</div>
        <div id="mesoTag">소모 메소: 0 메소</div>
        <div id="azmosTag" style="display:none; color:#a1a1aa; font-size:0.85rem;">아즈모스 협곡 1만점: 0주</div>
        <div id="cubeTypeTag" class="tag">
          <span class="tag-dot"></span>
          <span>윗잠재</span>
        </div>
      </div>
    </section>

    <!-- 4. 로그 (토글 가능) -->
    <section class="card" id="card-log">
      <h2>
        <div class="log-header-row">
          <span>로그 (최근 100회)</span>
          <button type="button" id="toggleLogBtn" class="log-toggle-btn">펼치기</button>
        </div>
      </h2>
      <div id="log" style="display:none;"></div>
    </section>
  </div>

  <!-- 메인 로직 스크립트 -->
  <script>
    const LAST_UPDATE_DATE = "2026-01-02";

    let bcProbs = [];
    let wcProbs = [];
    let acProbs = []; // 명장의 큐브(윗잠재)
    let allProbs = [];

    const CUBE_ID_BLACK = "5062010";   // 기존 윗잠재(블랙)
    const CUBE_ID_ADDI  = "5062500";   // 기존 에디
    const CUBE_ID_MEISTER = "2711004"; // acprobs.json 확인값

    let currentLines = [];
    let rollCandidates = [[], [], []];

    let meisterUsed = 0; // 명장의 큐브 소모량(개)
    let rollCount = 0;
    let mesoUsed = 0;
    let logEntries = [];

    let logVisible = false;

    const poolCache = new Map();

    const ONLY_ONE_KEYWORDS = [
      "쓸만한",
      "피격 후 무적"
    ];
    const AT_MOST_TWO_KEYWORDS = [
      "피격 시 일정 확률로 데미지",
      "피격 시 일정 확률로 일정 시간 무적"
    ];

    async function loadData() {
      const [bc, wc, ac] = await Promise.all([
        fetch("bcprobs.json").then(r => r.json()),
        fetch("wcprobs.json").then(r => r.json()),
        fetch("acprobs.json").then(r => r.json())
      ]);
      bcProbs = bc;
      wcProbs = wc;
      acProbs = ac;

      allProbs = [...bcProbs, ...wcProbs, ...acProbs]; // 핵심
      console.log("데이터 로드 완료:", allProbs.length);
      initCurrentOption();
    }

    function formatAzmosWeeksFromCubes(cubes) {
      const weeks = Math.ceil((cubes || 0) / 29); // 29개/주, 올림
      if (weeks <= 52) return `${weeks}주`;

      const years = Math.floor(weeks / 52);
      const rem = weeks % 52;
      if (rem === 0) return `${years}년`;
      return `${years}년 ${rem}주`;
    }


    function getSelectedLevel() {
      return Number(document.getElementById("itemLevel").value);
    }
    function getSelectedPartsType() {
      return Number(document.getElementById("partsType").value);
    }
    function getSelectedCubeId() {
      const kind = document.querySelector('input[name="cubeKind"]:checked').value;

      if (kind === "addi") return CUBE_ID_ADDI;
      if (kind === "meister") return CUBE_ID_MEISTER;

      // default: black
      return CUBE_ID_BLACK;
    }

    // 주스탯 getter (자동 스크립트에서 사용 예정)
    function getSelectedMainStat() {
      const r = document.querySelector('input[name="mainStat"]:checked');
      return r ? r.value : "STR";
    }

    function updateCubeTag() {
      const cubeId = getSelectedCubeId();
      const tag = document.getElementById("cubeTypeTag").querySelector("span:last-child");

      if (cubeId === CUBE_ID_ADDI) tag.textContent = "아랫잠재";
      else if (cubeId === CUBE_ID_MEISTER) tag.textContent = "명장의 큐브";
      else tag.textContent = "윗잠재";
    }


    function formatMesoKorean(v) {
    if (!v) return "0 메소";
    const isNegative = v < 0;
    let n = Math.abs(v);

    // ✅ 조 단위 추가 (10^12)
    const jo  = Math.floor(n / 1000000000000); // 1,000,000,000,000
    n = n % 1000000000000;

    const eok = Math.floor(n / 100000000);     // 1억
    n = n % 100000000;

    const man = Math.floor(n / 10000);         // 1만
    const one = n % 10000;

    const parts = [];
    if (jo)  parts.push(jo  + "조");
    if (eok) parts.push(eok + "억");
    if (man) parts.push(man + "만");
    if (one || parts.length === 0) parts.push(one.toLocaleString("ko-KR"));

    return (isNegative ? "-" : "") + parts.join(" ") + " 메소";
    }


    function updateStatsTags() {
      const cubeId = getSelectedCubeId();

      const rollCountEl = document.getElementById("rollCountTag");
      const mesoTag = document.getElementById("mesoTag");
      const azmosTag = document.getElementById("azmosTag");

      if (cubeId === CUBE_ID_MEISTER) {
        // ✅ 명장: 재설정 횟수는 숨김(소모 큐브로 충분)
        if (rollCountEl) rollCountEl.style.display = "none";

        if (mesoTag) mesoTag.textContent = `소모된 명장의 큐브: ${meisterUsed}개`;

        if (azmosTag) {
          azmosTag.style.display = "block";
          azmosTag.textContent = `아즈모스 협곡 1만점: ${formatAzmosWeeksFromCubes(meisterUsed)}`;
        }
        return;
      }

      // 블랙/에디: 재설정 횟수 표시 + 메소 표시
      if (rollCountEl) {
        rollCountEl.style.display = "block";
        rollCountEl.textContent = `재설정 횟수: ${rollCount}`;
      }

      if (mesoTag) mesoTag.textContent = `소모 메소: ${formatMesoKorean(mesoUsed)}`;
      if (azmosTag) azmosTag.style.display = "none";
    }



    function updateLogVisibility() {
      // 업데이트 날짜 표시
      const updateDateEl = document.getElementById("updateDate");
      if (updateDateEl) {
        updateDateEl.textContent = `업데이트: ${LAST_UPDATE_DATE}`;
      }

      const logDiv = document.getElementById("log");
      const btn = document.getElementById("toggleLogBtn");
      if (logVisible) {
        logDiv.style.display = "block";
        btn.textContent = "접기";
      } else {
        logDiv.style.display = "none";
        btn.textContent = "펼치기";
      }
    }

    function getCostPerSet(level, cubeItemID) {
      const isAddi = cubeItemID === "5062500";
      const tableMain = [
        {min:250, max:300, cost: 50000000},
        {min:200, max:249, cost: 45000000},
        {min:160, max:199, cost: 42500000},
        {min:1,   max:159, cost: 40000000}
      ];
      const tableAddi = [
        {min:250, max:300, cost: 98000000},
        {min:200, max:249, cost: 88000000},
        {min:160, max:199, cost: 83000000},
        {min:1,   max:159, cost: 78000000}
      ];
      const table = isAddi ? tableAddi : tableMain;
      for (const row of table) {
        if (level >= row.min && level <= row.max) return row.cost;
      }
      return table[table.length - 1].cost;
    }

    function poolKey(cubeItemID, partsType, level, line) {
      return `${cubeItemID}-${partsType}-${level}-${line}`;
    }

    function getBasePool(cubeItemID, partsType, level, line) {
      const key = poolKey(cubeItemID, partsType, level, line);
      if (poolCache.has(key)) return poolCache.get(key);
      const pool = allProbs.filter(
        r =>
          r.cubeItemID === cubeItemID &&
          r.partsType === partsType &&
          r.reqLev === level &&
          r.line === line
      );
      poolCache.set(key, pool);
      return pool;
    }

    function textMatchesAny(text, keywords) {
      return keywords.some(kw => text.includes(kw));
    }
    function isGroupOne(text) {
      return textMatchesAny(text, ONLY_ONE_KEYWORDS);
    }
    function isGroupTwo(text) {
      return textMatchesAny(text, AT_MOST_TWO_KEYWORDS);
    }

    function rollOneLine({cubeItemID, partsType, level, line, existingLines}) {
      const basePool = getBasePool(cubeItemID, partsType, level, line);
      if (!basePool.length) return null;

      const countG1 = existingLines.filter(l => isGroupOne(l.optionText)).length;
      const countG2 = existingLines.filter(l => isGroupTwo(l.optionText)).length;

      const filtered = [];
      for (const row of basePool) {
        const text = row.optionText;
        if (isGroupOne(text) && countG1 >= 1) continue;
        if (isGroupTwo(text) && countG2 >= 2) continue;
        filtered.push(row);
      }
      if (!filtered.length) return null;

      let totalProb = 0;
      for (const row of filtered) totalProb += row.probability;

      const r = Math.random() * totalProb;
      let acc = 0;
      for (const row of filtered) {
        acc += row.probability;
        if (r <= acc) {
          return { line, optionText: row.optionText, raw: row };
        }
      }
      const last = filtered[filtered.length - 1];
      return { line, optionText: last.optionText, raw: last };
    }

    function isSameSet(aLines, bLines) {
      if (!aLines || !bLines) return false;
      if (aLines.length !== 3 || bLines.length !== 3) return false;
      for (let i = 0; i < 3; i++) {
        if (aLines[i].optionText !== bLines[i].optionText) return false;
      }
      return true;
    }

    function rollOneSet(context) {
      // ====== (1) 사전검증: 해당 조합이 데이터에 존재하지 않으면 즉시 실패 ======
      // getBasePool은 cubeItemID/partsType/reqLev/line 완전 일치로 필터링하므로,
      // 존재하지 않는 조합이면 basePool이 비고 rollOneLine이 null을 반환한다. :contentReference[oaicite:4]{index=4}
      for (let line = 1; line <= 3; line++) {
        const base = getBasePool(context.cubeItemID, context.partsType, context.level, line);
        if (!base || base.length === 0) return null;
      }

      // ====== (2) 안전장치: 최대 시도 횟수 제한 (무한루프 방지) ======
      const MAX_ATTEMPTS = 5000;

      for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt++) {
        const lines = [];
        for (let line = 1; line <= 3; line++) {
          const opt = rollOneLine({
            cubeItemID: context.cubeItemID,
            partsType: context.partsType,
            level: context.level,
            line,
            existingLines: lines
          });
          if (!opt) break;
          lines.push(opt);
        }
        if (lines.length !== 3) continue;
        if (isSameSet(lines, currentLines)) continue;
        return lines;
      }

      // 시도 횟수를 다 써도 3줄 세트를 못 만들면 실패로 간주
      return null;
    }


    function renderLines(elemId, lines) {
      const elem = document.getElementById(elemId);
      elem.innerHTML = "";
      if (!lines || !lines.length) {
        elem.innerHTML = "<div style='color:#71717a;'>-</div>";
        return;
      }
      for (const l of lines) {
        const div = document.createElement("div");
        div.textContent = l.optionText;
        elem.appendChild(div);
      }
    }

    function renderAllBoxes() {
      renderLines("lines-current", currentLines);
      renderLines("lines-roll1", rollCandidates[0]);
      renderLines("lines-roll2", rollCandidates[1]);
      renderLines("lines-roll3", rollCandidates[2]);
    }

    function appendLogEntry(text) {
      logEntries.unshift(text);
      if (logEntries.length > 100) logEntries.pop();
      document.getElementById("log").textContent = logEntries.join("\n");
    }

    function initCurrentOption() {
      const cubeItemID = getSelectedCubeId();
      const level = getSelectedLevel();
      const partsType = getSelectedPartsType();
      const ctx = { cubeItemID, partsType, level };

      const first = rollOneSet(ctx);
      if (!first) {
        // invalid 조합: 프리즈 대신 정상 실패 처리
        currentLines = [];
        rollCandidates = [[], [], []];
        rollCount = 0;
        mesoUsed = 0;
        meisterUsed = 0;
        logEntries = [];
        document.getElementById("log").textContent = "";
        updateCubeTag();
        updateStatsTags();
        renderAllBoxes();
        alert("선택한 레벨/부위 조합은 데이터가 없어 옵션을 생성할 수 없습니다. 다른 레벨을 선택하세요.");
        return;
      }

      currentLines = first;
      rollCandidates = [[], [], []];

      rollCount = 0;
      mesoUsed = 0;
      logEntries = [];
      document.getElementById("log").textContent = "";
      updateCubeTag();
      updateStatsTags();
      renderAllBoxes();
    }

    function doOneRollStep() {
      const cubeItemID = getSelectedCubeId();
      const level = getSelectedLevel();
      const partsType = getSelectedPartsType();
      const ctx = { cubeItemID, partsType, level };

      const cubeId = cubeItemID; // 의미상 동일. 기존 변수명 유지하고 싶으면 cubeId로 통일
      const costPerSet = (cubeId === CUBE_ID_MEISTER) ? 0 : getCostPerSet(level, cubeId);

      const cand1 = rollOneSet(ctx);
      const cand2 = rollOneSet(ctx);
      const cand3 = rollOneSet(ctx);

      if (!cand1 || !cand2 || !cand3) {
        rollCandidates = [[], [], []];
        renderAllBoxes();
        alert("선택한 레벨/부위 조합은 데이터가 없어 재설정할 수 없습니다. 다른 조합을 선택하세요.");
        return;
      }

      rollCandidates = [cand1, cand2, cand3];
      rollCount += 3;

      if (cubeId === CUBE_ID_MEISTER) meisterUsed += 3;
      else mesoUsed += costPerSet * 3;
      // 로그 포맷: 헤더 + 1/2/3 줄로 가독성 있게
      const cubeLabel = cubeItemID === "5062500" ? "에디" : "윗";
      const partLabel = document.getElementById("partsType").selectedOptions[0].text;
      const header = `[${rollCount - 2}~${rollCount}] LV${level} ${cubeLabel} ${partLabel}`;
      const line1 = `  1) ${cand1.map(l=>l.optionText).join(" | ")}`;
      const line2 = `  2) ${cand2.map(l=>l.optionText).join(" | ")}`;
      const line3 = `  3) ${cand3.map(l=>l.optionText).join(" | ")}`;
      appendLogEntry(`${header}\n${line1}\n${line2}\n${line3}`);

      updateStatsTags();
      renderAllBoxes();
      triggerCandidatesFadeIn();
    }

    function triggerCandidatesFadeIn() {
      const ids = ["box-roll1", "box-roll2", "box-roll3"];
      ids.forEach(id => {
        const el = document.getElementById(id);
        el.classList.remove("fade-in-fast");
        void el.offsetWidth;
        el.classList.add("fade-in-fast");
        el.addEventListener("animationend", () => {
          el.classList.remove("fade-in-fast");
        }, { once:true });
      });
    }

    function chooseCandidate(idx) {
      const cand = rollCandidates[idx];
      if (!cand || !cand.length) return;

      const boxId = `box-roll${idx + 1}`;
      const candBox = document.getElementById(boxId);
      const currentBox = document.getElementById("box-current");

      candBox.classList.remove("fade-out-card");
      void candBox.offsetWidth;
      candBox.classList.add("fade-out-card");

      candBox.addEventListener("animationend", () => {
        candBox.classList.remove("fade-out-card");

        currentLines = cand.map(l => ({...l}));
        renderAllBoxes();

        currentBox.classList.remove("fade-in-card");
        void currentBox.offsetWidth;
        currentBox.classList.add("fade-in-card");
        currentBox.addEventListener("animationend", () => {
          currentBox.classList.remove("fade-in-card");
        }, { once:true });
      }, { once:true });
    }

    // ============= 이벤트 바인딩 =============
    document.getElementById("applyResetBtn").addEventListener("click", () => {
      meisterUsed = 0;
      mesoUsed = 0;
      rollCount = 0;
      initCurrentOption();
    });


    document.getElementById("rollBtn").addEventListener("click", () => {
      doOneRollStep();
    });

    document.querySelectorAll(".option-box.candidate").forEach(box => {
      box.addEventListener("click", (e) => {
        const idx = Number(e.currentTarget.getAttribute("data-choice")) - 1;
        chooseCandidate(idx);
      });
    });

    document.querySelectorAll('input[name="cubeKind"]').forEach(r => {
      r.addEventListener("change", () => {
        // 큐브 타입 변경 시 통계 초기화
        meisterUsed = 0;
        mesoUsed = 0;
        rollCount = 0;

        updateCubeTag();
        initCurrentOption();
      });
    });


    document.getElementById("itemLevel").addEventListener("change", () => {
      initCurrentOption();
    });
    document.getElementById("partsType").addEventListener("change", () => {
      initCurrentOption();
    });

    document.getElementById("toggleLogBtn").addEventListener("click", () => {
      logVisible = !logVisible;
      updateLogVisibility();
    });

    updateLogVisibility();

    // ====== 업데이트 내역 토글 ======
    window.addEventListener("load", () => {
      const box = document.getElementById("changelog");
      const btn = document.getElementById("toggleChangelogBtn");
      if (!box || !btn) return;

      let changelogVisible = false;

      function updateChangelogVisibility() {
        box.style.display = changelogVisible ? "block" : "none";
        btn.textContent = changelogVisible ? "업데이트 내역 접기" : "업데이트 내역 보기";
      }

      btn.addEventListener("click", () => {
        changelogVisible = !changelogVisible;
        updateChangelogVisibility();
      });

      updateChangelogVisibility(); // 초기 상태 반영
    });


    loadData().catch(err => {
      console.error("데이터 로드 실패:", err);
      alert("bcprobs.json / wcprobs.json을 불러오지 못했습니다. 파일 위치를 확인하세요.");
    });
  </script>

  <!-- 자동 돌리기 전용 스크립트 (별도 파일) -->
  <script src="autoRoll.js"></script>
  <footer style="margin-top:18px; color:#71717a; font-size:0.75rem; text-align:center;">
    <div>제작: 크로아 - 윈메롱</div>
  
    <div style="margin-top:6px;">
      <button type="button" id="toggleChangelogBtn"
        style="border-radius:999px; border:1px solid #3f3f46; background:#111111; color:#e5e7eb; font-size:0.75rem; padding:2px 10px; cursor:pointer;">
        업데이트 내역 보기
      </button>
    </div>
  
    <div id="changelog"
     style="display:none;
            margin:12px auto 0;
            max-width:900px;
            text-align:left;
            padding:12px 14px;
            background:#111111;
            border-radius:10px;
            border:1px solid #27272a;
            white-space:normal;
            color:#e5e7eb;
            font-size:0.9rem;
            line-height:1.35;">

      <!-- 아래에 업데이트 내역을 계속 쌓아가면 됩니다 -->
      <div style="margin-bottom:10px;">
        <div style="color:#e5e7eb; font-weight:600;">2026-01-02</div>
        <div>- 방어구/장신구 윗잠재 자동 돌리기 기능 추가</div>
        <div>- 방어구/장신구 아랫랫잠재 자동 돌리기 기능 추가</div>
        <div>- 제논 올스탯 자동돌리기 지원원</div>
        <div style="color:#e5e7eb; font-weight:600;">2025-12-30</div>
        <div>- 명장의 큐브 선택 가능, 아즈모스 협곡 1만점 기준으로 필요기간 표시</div>
        <div>- 자동돌리기 목표 옵션이 등장했을 때, 특수 효과 추가</div>
        <div>- 방패, 소울링/포스실드 자동 돌리기 지원</div>
        <div>- 현재 존재하지 않는 레벨과 장비 조합을 선택했을 때 페이지가 프리징되는 버그 수정</div>
        <div style="color:#e5e7eb; font-weight:600;">2025-12-26</div>
        <div>- 무보엠 윗잠 자동 돌리기 기능 추가</div>
        <div style="color:#e5e7eb; font-weight:600;">2025-11-27</div>
        <div>- 3번 돌리기 기능만 탑재하여 github 업로드</div>
      </div>
    </div>
  </footer>  
</body>
</html>
