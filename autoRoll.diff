diff --git a/autoRoll.js b/autoRoll.js
index 5297bc550234544390a1a16e0be7b0c1eceb3a69..9afdddd5cc24071fe0101f216352311423fd3dbf 100644
--- a/autoRoll.js
+++ b/autoRoll.js
@@ -94,241 +94,262 @@
 
   function isAdditionalCubeSelected() {
     return getSelectedCubeIdSafe() === CUBE_ID_ADDI;
   }
 
   function getMainStat() {
     if (typeof getSelectedMainStat === "function") {
       return getSelectedMainStat();
     }
     return "STR";
   }
 
   function getEffectiveMainStat() {
     const stat = getMainStat();
     if (stat === "ANY" && isWeaponPartsType(getSelectedPartsTypeSafe())) {
       return "STR";
     }
     return stat;
   }
 
   function getMainKeyword(mainStat) {
     // ê¸°ì¡´ mainStat INTì´ë©´ "ë§ˆë ¥" ê¸°ì¤€ì„ ìœ ì§€
     return mainStat === "INT" ? "ë§ˆë ¥" : "ê³µê²©ë ¥";
   }
 
-  function getAdditionalMainStatTypes(statType) {
-    if (statType === "ANY") {
-      return ["STR", "DEX", "INT", "LUK"];
-    }
-    return [statType];
-  }
+  function getAdditionalMainStatTypes(statType) {
+    if (statType === "ANY") {
+      return ["STR", "DEX", "INT", "LUK"];
+    }
+    if (statType === "ALLSTAT") {
+      return ["STR", "DEX", "LUK"];
+    }
+    return [statType];
+  }
 
   // ====== Line identifier helpers (ì˜µì…˜ í…ìŠ¤íŠ¸ ê¸°ë°˜) ======
   function isIEDLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     // "ëª¬ìŠ¤í„° ë°©ì–´ìœ¨ ë¬´ì‹œ" / "ë°©ì–´ìœ¨ ë¬´ì‹œ" ë“± í­ë„“ê²Œ ìˆ˜ìš©
     return text.includes("ë°©ì–´") && text.includes("ë¬´ì‹œ") && (text.includes("ìœ¨") || text.includes("ë°©ì–´ë ¥"));
   }
 
   function isBossLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     return (text.includes("ë³´ìŠ¤") && text.includes("ë°ë¯¸ì§€")) || text.includes("ë³´ìŠ¤ ëª¬ìŠ¤í„°") || text.includes("ë³´ìŠ¤ ê³µê²©");
   }
 
   function isAtkLine(line, mainStat) {
     const text = (line && line.optionText) ? line.optionText : "";
     const keyword = getMainKeyword(mainStat);
     if (!text.includes(keyword)) return false;
     // % ê¸°ë°˜ ì˜µì…˜ë§Œ ì¸ì •
     return /\+(\d+)%/.test(text);
   }
 
   // candLines: rollOneSetìœ¼ë¡œ ë‚˜ì˜¨ 3ì¤„ì§œë¦¬ ë°°ì—´
   // ğŸ‘‰ ì„¸ ì¤„ì— í¬í•¨ëœ ê³µê²©ë ¥/ë§ˆë ¥ %ë¥¼ ëª¨ë‘ í•©ì‚°
   function getTotalAtkPercentInSet(candLines, mainStat) {
     if (!candLines) return 0;
     const keyword = getMainKeyword(mainStat);
     let sum = 0;
     for (const line of candLines) {
       const text = line.optionText || "";
       if (!text.includes(keyword)) continue;
       const m = text.match(/\+(\d+)%/);
       if (!m) continue;
       const val = parseInt(m[1], 10);
       if (!isNaN(val)) sum += val;
     }
     return sum;
   }
 
-  function getStatTotalsInSet(candLines) {
-    const totals = { STR: 0, DEX: 0, INT: 0, LUK: 0 };
-    if (!Array.isArray(candLines)) return totals;
-    for (const line of candLines) {
-      const text = line.optionText || "";
-      const statMatch = text.match(/^(STR|DEX|INT|LUK) \+(\d+)%/);
-      if (statMatch) {
-        const value = parseInt(statMatch[2], 10);
-        if (!isNaN(value)) {
-          totals[statMatch[1]] += value;
-        }
-      }
-      const allMatch = text.match(/^ì˜¬ìŠ¤íƒ¯ \+(\d+)%/);
-      if (allMatch) {
-        const value = parseInt(allMatch[1], 10);
-        if (!isNaN(value)) {
-          totals.STR += value;
-          totals.DEX += value;
-          totals.INT += value;
-          totals.LUK += value;
-        }
-      }
-    }
-    return totals;
-  }
-
-  function getStatTotalByType(candLines, statType) {
-    const totals = getStatTotalsInSet(candLines);
-    if (statType === "ANY") {
-      return Math.max(totals.STR, totals.DEX, totals.INT, totals.LUK);
-    }
-    return totals[statType] || 0;
-  }
+  function getStatTotalsInSet(candLines) {
+    const totals = { STR: 0, DEX: 0, INT: 0, LUK: 0, ALLSTAT: 0 };
+    if (!Array.isArray(candLines)) return totals;
+    for (const line of candLines) {
+      const text = line.optionText || "";
+      const statMatch = text.match(/^(STR|DEX|INT|LUK) \+(\d+)%/);
+      if (statMatch) {
+        const value = parseInt(statMatch[2], 10);
+        if (!isNaN(value)) {
+          totals[statMatch[1]] += value;
+        }
+      }
+      const allMatch = text.match(/^ì˜¬ìŠ¤íƒ¯ \+(\d+)%/);
+      if (allMatch) {
+        const value = parseInt(allMatch[1], 10);
+        if (!isNaN(value)) {
+          totals.ALLSTAT += value;
+        }
+      }
+    }
+    return totals;
+  }
+
+  function getStatTotalByType(candLines, statType) {
+    const totals = getStatTotalsInSet(candLines);
+    if (statType === "ANY") {
+      return Math.max(
+        totals.STR + totals.ALLSTAT,
+        totals.DEX + totals.ALLSTAT,
+        totals.INT + totals.ALLSTAT,
+        totals.LUK + totals.ALLSTAT
+      );
+    }
+    if (statType === "ALLSTAT") {
+      return totals.ALLSTAT + (totals.STR + totals.DEX + totals.LUK) / 3;
+    }
+    return (totals[statType] || 0) + totals.ALLSTAT;
+  }
 
   function getCooldownTotal(candLines) {
     if (!Array.isArray(candLines)) return 0;
     let sum = 0;
     for (const line of candLines) {
       const text = line.optionText || "";
       const match = text.match(/ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ -(\d+)ì´ˆ/);
       if (match) {
         const value = parseInt(match[1], 10);
         if (!isNaN(value)) sum += value;
       }
     }
     return sum;
   }
 
   function countCritDamageLines(candLines) {
     if (!Array.isArray(candLines)) return 0;
     let count = 0;
     for (const line of candLines) {
       const text = line.optionText || "";
       if (text.includes("í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€")) count += 1;
     }
     return count;
   }
 
   function countDropMesoLines(candLines) {
     if (!Array.isArray(candLines)) return 0;
     let count = 0;
     for (const line of candLines) {
       const text = line.optionText || "";
       if (text.includes("ë©”ì†Œ íšë“ëŸ‰") || text.includes("ì•„ì´í…œ ë“œë¡­ë¥ ")) {
         count += 1;
       }
     }
     return count;
   }
 
   function countLines(lines, predicate) {
     if (!Array.isArray(lines)) return 0;
     let c = 0;
     for (const l of lines) if (predicate(l)) c++;
     return c;
   }
 
   function isAllStatPercentLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     return /^ì˜¬ìŠ¤íƒ¯ \+\d+%$/.test(text);
   }
 
-  function isMainStatPercentLine(line, statType) {
-    const text = (line && line.optionText) ? line.optionText : "";
-    const types = getAdditionalMainStatTypes(statType);
-    return types.some(type => new RegExp(`^${type} \\+\\d+%$`).test(text));
-  }
+  function isMainStatPercentLine(line, statType) {
+    const text = (line && line.optionText) ? line.optionText : "";
+    const types = getAdditionalMainStatTypes(statType);
+    if (statType === "ALLSTAT" && isAllStatPercentLine(line)) return true;
+    return types.some(type => new RegExp(`^${type} \\+\\d+%$`).test(text));
+  }
 
-  function isMainStatFlatLine(line, statType) {
-    const text = (line && line.optionText) ? line.optionText : "";
-    const types = getAdditionalMainStatTypes(statType);
-    return types.some(type => new RegExp(`^${type} \\+\\d+$`).test(text));
-  }
+  function isMainStatFlatLine(line, statType) {
+    const text = (line && line.optionText) ? line.optionText : "";
+    const types = getAdditionalMainStatTypes(statType);
+    return types.some(type => new RegExp(`^${type} \\+\\d+$`).test(text));
+  }
 
   function isAdditionalAttackFlatLine(line, statType) {
     const text = (line && line.optionText) ? line.optionText : "";
     if (statType === "INT") {
       return /^ë§ˆë ¥ \+\d+$/.test(text);
     }
     if (statType === "ANY") {
       return /^(ê³µê²©ë ¥|ë§ˆë ¥) \+\d+$/.test(text);
     }
     return /^ê³µê²©ë ¥ \+\d+$/.test(text);
   }
 
   function isAdditionalCritDamageLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     return /^í¬ë¦¬í‹°ì»¬ ë°ë¯¸ì§€ \+\d+%$/.test(text);
   }
 
   function isAdditionalCooldownLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     return text === "ìŠ¤í‚¬ ì¬ì‚¬ìš© ëŒ€ê¸°ì‹œê°„ -1ì´ˆ";
   }
 
-  function isAdditionalPerLevelStatLine(line, statType) {
-    const text = (line && line.optionText) ? line.optionText : "";
-    const types = getAdditionalMainStatTypes(statType);
-    return types.some(type => new RegExp(`^ìºë¦­í„° ê¸°ì¤€ 9ë ˆë²¨ ë‹¹ ${type} \\+\\d+$`).test(text));
-  }
-
-  function isAdditionalValidLine(line, statType) {
+  function isAdditionalPerLevelStatLine(line, statType) {
+    const text = (line && line.optionText) ? line.optionText : "";
+    const types = getAdditionalMainStatTypes(statType);
+    return types.some(type => new RegExp(`^ìºë¦­í„° ê¸°ì¤€ 9ë ˆë²¨ ë‹¹ ${type} \\+\\d+$`).test(text));
+  }
+
+  function isAdditionalValidLine(line, statType) {
     return (
       isMainStatPercentLine(line, statType) ||
       isAllStatPercentLine(line) ||
       isMainStatFlatLine(line, statType) ||
       isAdditionalAttackFlatLine(line, statType) ||
       isAdditionalCritDamageLine(line) ||
       isAdditionalCooldownLine(line) ||
       isAdditionalPerLevelStatLine(line, statType)
     );
-  }
-
-  function isAdditionalStatValidSet(candLines, criteria) {
-    if (!Array.isArray(candLines) || candLines.length !== 3) return false;
-    const validCount = countLines(candLines, line => isAdditionalValidLine(line, criteria.statType));
-
-    if (criteria.requiredLines === 2) {
-      return validCount >= 2;
-    }
-
-    if (validCount >= 3) return true;
-
-    const firstLine = candLines[0];
-    const secondLine = candLines[1];
-    const firstIsMainPercent = isMainStatPercentLine(firstLine, criteria.statType);
-    const secondIsMainPercent = isMainStatPercentLine(secondLine, criteria.statType) || isAllStatPercentLine(secondLine);
+  }
+
+  function isAllStatSelection(statType) {
+    return statType === "ALLSTAT";
+  }
+
+  function isAdditionalStatValidSet(candLines, criteria) {
+    if (!Array.isArray(candLines) || candLines.length !== 3) return false;
+    const validCount = countLines(candLines, line => isAdditionalValidLine(line, criteria.statType));
+    const allStatCount = isAllStatSelection(criteria.statType)
+      ? countLines(candLines, isAllStatPercentLine)
+      : 0;
+
+    if (isAllStatSelection(criteria.statType)) {
+      if (criteria.requiredLines === 2 && allStatCount < 1) return false;
+      if (criteria.requiredLines === 3 && allStatCount < 2) return false;
+    }
+
+    if (criteria.requiredLines === 2) {
+      return validCount >= 2;
+    }
+
+    if (validCount >= 3) return true;
+
+    const firstLine = candLines[0];
+    const secondLine = candLines[1];
+    const firstIsMainPercent = isMainStatPercentLine(firstLine, criteria.statType);
+    const secondIsMainPercent = isMainStatPercentLine(secondLine, criteria.statType) || isAllStatPercentLine(secondLine);
     return firstIsMainPercent && secondIsMainPercent;
   }
 
   function isMainValidSet(candLines, partsType, iedMaxN, bossMinM) {
     if (!Array.isArray(candLines) || candLines.length !== 3) return false;
     const mainStat = getEffectiveMainStat();
   
     const iedCount = countLines(candLines, isIEDLine);
   
     // âœ… ë³€ê²½: "ì •í™•íˆ N"ì´ ì•„ë‹ˆë¼ "ìµœëŒ€ N" (0~N í—ˆìš©)
     if (iedCount > iedMaxN) return false;
   
     if (partsType === PARTS.EMBLEM) {
       // ì— ë¸”ë ˜: Boss ì—†ìŒ (í˜¹ì‹œ ë°ì´í„°ì— ì„ì´ë©´ ë¬´íš¨ ì²˜ë¦¬)
       const bossCount = countLines(candLines, isBossLine);
       if (bossCount > 0) return false;
   
       // IEDê°€ ì•„ë‹Œ ì¤„ì€ ì „ë¶€ ATK/MATK% ì´ì–´ì•¼ í•¨
       for (const l of candLines) {
         if (isIEDLine(l)) continue;
         if (!isAtkLine(l, mainStat)) return false;
       }
       return true;
     }
   
