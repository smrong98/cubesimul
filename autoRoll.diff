diff --git a/autoRoll.js b/autoRoll.js
index 277c5835d77168d5cb94943b7544f4cd1bfa1a5d..9056ae50e7c8d41d5bda313d823ba3b8867874e9 100644
--- a/autoRoll.js
+++ b/autoRoll.js
@@ -41,50 +41,54 @@
     PARTS.EARRING,
     PARTS.RING,
     PARTS.PENDANT
   ]);
 
   const ARMOR_PARTS = new Set([
     PARTS.HAT,
     PARTS.TOP,
     PARTS.OVERALL,
     PARTS.BOTTOM,
     PARTS.SHOES,
     PARTS.GLOVE,
     PARTS.CAPE,
     PARTS.BELT,
     PARTS.SHOULDER,
     PARTS.HEART
   ]);
 
   const CUBE_ID_ADDI = "5062500";
   const CUBE_ID_MAIN = "5062010";
 
   function getSelectedPartsTypeSafe() {
     return typeof getSelectedPartsType === "function" ? getSelectedPartsType() : 0;
   }
 
+  function getSelectedLevelSafe() {
+    return typeof getSelectedLevel === "function" ? getSelectedLevel() : 0;
+  }
+
   function isWeaponPartsType(p) {
     return WEAPON_PARTS.has(p);
   }
 
   function isAccessoryPartsType(p) {
     return ACCESSORY_PARTS.has(p);
   }
 
   function isArmorPartsType(p) {
     return ARMOR_PARTS.has(p);
   }
 
   function isSupportedParts() {
     const p = getSelectedPartsTypeSafe();
     if (isAdditionalCubeSelected()) {
       return isWeaponPartsType(p) || isAccessoryPartsType(p) || isArmorPartsType(p);
     }
     return isWeaponPartsType(p) || isAccessoryPartsType(p) || isArmorPartsType(p);
   }
 
   function isWeaponOrSecondarySelected() {
     const p = getSelectedPartsTypeSafe();
     return isWeaponPartsType(p) && p !== PARTS.EMBLEM;
   }
   
@@ -94,50 +98,78 @@
 
   function isAdditionalCubeSelected() {
     return getSelectedCubeIdSafe() === CUBE_ID_ADDI;
   }
 
   function getMainStat() {
     if (typeof getSelectedMainStat === "function") {
       return getSelectedMainStat();
     }
     return "STR";
   }
 
   function getEffectiveMainStat() {
     const stat = getMainStat();
     if (stat === "ANY" && isWeaponPartsType(getSelectedPartsTypeSafe())) {
       return "STR";
     }
     return stat;
   }
 
   function getMainKeyword(mainStat) {
     // 기존 mainStat INT이면 "마력" 기준을 유지
     return mainStat === "INT" ? "마력" : "공격력";
   }
 
+  const line1OptionCache = new Map();
+
+  function getLine1OptionSet(context) {
+    if (!context || typeof getBasePool !== "function") return null;
+    const key = `${context.cubeItemID}-${context.partsType}-${context.level}`;
+    if (line1OptionCache.has(key)) return line1OptionCache.get(key);
+
+    const pool = getBasePool(context.cubeItemID, context.partsType, context.level, 1);
+    if (!Array.isArray(pool) || pool.length === 0) {
+      line1OptionCache.set(key, null);
+      return null;
+    }
+    const set = new Set(pool.map(row => row.optionText));
+    line1OptionCache.set(key, set);
+    return set;
+  }
+
+  function hasDepartureLine(candLines, context) {
+    if (!Array.isArray(candLines) || candLines.length !== 3) return false;
+    const line1Set = getLine1OptionSet(context);
+    if (!line1Set) return false;
+    for (let i = 1; i < candLines.length; i++) {
+      const text = candLines[i] && candLines[i].optionText ? candLines[i].optionText : "";
+      if (text && line1Set.has(text)) return true;
+    }
+    return false;
+  }
+
   function getAdditionalMainStatTypes(statType) {
     if (statType === "ANY") {
       return ["STR", "DEX", "INT", "LUK"];
     }
     if (statType === "ALLSTAT") {
       return ["STR", "DEX", "LUK"];
     }
     return [statType];
   }
 
   // ====== Line identifier helpers (옵션 텍스트 기반) ======
   function isIEDLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     // "몬스터 방어율 무시" / "방어율 무시" 등 폭넓게 수용
     return text.includes("방어") && text.includes("무시") && (text.includes("율") || text.includes("방어력"));
   }
 
   function isBossLine(line) {
     const text = (line && line.optionText) ? line.optionText : "";
     return (text.includes("보스") && text.includes("데미지")) || text.includes("보스 몬스터") || text.includes("보스 공격");
   }
 
   function isAtkLine(line, mainStat) {
     const text = (line && line.optionText) ? line.optionText : "";
     const keyword = getMainKeyword(mainStat);
@@ -309,82 +341,86 @@
   function isAdditionalStatValidSet(candLines, criteria) {
     if (!Array.isArray(candLines) || candLines.length !== 3) return false;
     const validCount = countLines(candLines, line => isAdditionalValidLine(line, criteria.statType));
     const allStatCount = isAllStatSelection(criteria.statType)
       ? countLines(candLines, isAllStatPercentLine)
       : 0;
 
     if (isAllStatSelection(criteria.statType)) {
       if (criteria.requiredLines === 2 && allStatCount < 1) return false;
       if (criteria.requiredLines === 3 && allStatCount < 2) return false;
     }
 
     if (criteria.requiredLines === 2) {
       return validCount >= 2;
     }
 
     if (validCount >= 3) return true;
 
     const firstLine = candLines[0];
     const secondLine = candLines[1];
     const firstIsMainPercent = isMainStatPercentLine(firstLine, criteria.statType);
     const secondIsMainPercent = isMainStatPercentLine(secondLine, criteria.statType) || isAllStatPercentLine(secondLine);
     return firstIsMainPercent && secondIsMainPercent;
   }
 
-  function isMainValidSet(candLines, partsType, iedMaxN, bossMaxM) {
+  function isMainValidSet(candLines, context, criteria) {
     if (!Array.isArray(candLines) || candLines.length !== 3) return false;
+    const partsType = context.partsType;
+    const iedMaxN = criteria.iedMaxN;
+    const bossMaxM = criteria.bossMaxM;
     const mainStat = getEffectiveMainStat();
   
     const iedCount = countLines(candLines, isIEDLine);
   
     // ✅ 변경: "정확히 N"이 아니라 "최대 N" (0~N 허용)
     if (iedCount > iedMaxN) return false;
   
     if (partsType === PARTS.EMBLEM) {
       // 엠블렘: Boss 없음 (혹시 데이터에 섞이면 무효 처리)
       const bossCount = countLines(candLines, isBossLine);
       if (bossCount > 0) return false;
   
       // IED가 아닌 줄은 전부 ATK/MATK% 이어야 함
       for (const l of candLines) {
         if (isIEDLine(l)) continue;
         if (!isAtkLine(l, mainStat)) return false;
       }
-      return true;
+      return !criteria.seekDeparture || hasDepartureLine(candLines, context);
     }
   
     // 무기/보조무기
     const bossCount = countLines(candLines, isBossLine);
     if (bossCount > bossMaxM) return false;
   
     // IED/Boss 제외 나머지 줄은 ATK/MATK% 이어야 유효
     for (const l of candLines) {
       if (isIEDLine(l)) continue;
       if (isBossLine(l)) continue;
       if (!isAtkLine(l, mainStat)) return false;
     }
+    if (criteria.seekDeparture && !hasDepartureLine(candLines, context)) return false;
     return true;
   }
 
   function isStatValidSet(candLines, partsType, criteria) {
     if (!Array.isArray(candLines) || candLines.length !== 3) return false;
     const baseStatTotal = getStatTotalByType(candLines, criteria.statType);
     const critLines = partsType === PARTS.GLOVE ? countCritDamageLines(candLines) : 0;
     const statTotal =
       partsType === PARTS.GLOVE && criteria.minCritLines === 0
         ? baseStatTotal + critLines * 32
         : baseStatTotal;
 
     if (partsType === PARTS.HAT && criteria.minCooldown > 0) {
       const cooldownTotal = getCooldownTotal(candLines);
       if (cooldownTotal >= criteria.minCooldown + 1) return true;
       return statTotal >= criteria.targetPercent && cooldownTotal >= criteria.minCooldown;
     }
 
     if (partsType === PARTS.GLOVE && criteria.minCritLines > 0) {
       if (critLines >= criteria.minCritLines + 1) return true;
       return baseStatTotal >= criteria.targetPercent && critLines >= criteria.minCritLines;
     }
 
     if (isAccessoryPartsType(partsType) && criteria.minDropMesoLines > 0) {
       const dropMesoLines = countDropMesoLines(candLines);
@@ -400,53 +436,57 @@
   function hasSatisfiedCandidateAdditional(targetPercent) {
     if (!Array.isArray(rollCandidates)) return false;
     const mainStat = getEffectiveMainStat();
     for (const cand of rollCandidates) {
       const total = getTotalAtkPercentInSet(cand, mainStat);
       if (total >= targetPercent) {
         return true;
       }
     }
     return false;
   }
 
   function hasSatisfiedCandidateAdditionalStat(criteria) {
     if (!Array.isArray(rollCandidates)) return false;
     for (const cand of rollCandidates) {
       if (isAdditionalStatValidSet(cand, criteria)) {
         return true;
       }
     }
     return false;
   }
 
   // ====== main(윗잠재) stop condition ======
   function hasSatisfiedCandidateMain(criteria) {
     if (!Array.isArray(rollCandidates)) return false;
-    const partsType = getSelectedPartsTypeSafe();
+    const context = {
+      cubeItemID: getSelectedCubeIdSafe(),
+      partsType: getSelectedPartsTypeSafe(),
+      level: getSelectedLevelSafe()
+    };
     for (const cand of rollCandidates) {
-      if (isMainValidSet(cand, partsType, criteria.iedMaxN, criteria.bossMaxM)) {
+      if (isMainValidSet(cand, context, criteria)) {
         return true;
       }
     }
     return false;
   }
 
   // ====== stat(장신구/방어구) stop condition ======
   function hasSatisfiedCandidateStat(criteria) {
     if (!Array.isArray(rollCandidates)) return false;
     const partsType = getSelectedPartsTypeSafe();
     for (const cand of rollCandidates) {
       if (isStatValidSet(cand, partsType, criteria)) {
         return true;
       }
     }
     return false;
   }
 
   function clearAutoHitUI() {
     ["box-roll1", "box-roll2", "box-roll3"].forEach(id => {
       const el = document.getElementById(id);
       if (!el) return;
       el.classList.remove("auto-hit");
       el.classList.remove("auto-hit-flash");
     });
@@ -592,53 +632,57 @@
       doOneRollStep();
       clearAutoHitUI();
     }
 
     if (payload && payload.mode === "addi-weapon") {
       // 3줄 합산 %가 목표 이상인 세트가 하나라도 있으면 종료
       if (hasSatisfiedCandidateAdditional(payload.targetPercent)) {
         applyAutoHitUIForCandidates(cand => {
           const mainStat = getEffectiveMainStat();
           return getTotalAtkPercentInSet(cand, mainStat) >= payload.targetPercent;
         });
         stopAuto();
         return;
       }
     } else if (payload && payload.mode === "addi-stat") {
       if (hasSatisfiedCandidateAdditionalStat(payload.criteria)) {
         applyAutoHitUIForCandidates(cand => {
           return isAdditionalStatValidSet(cand, payload.criteria);
         });
         stopAuto();
         return;
       }
     } else if (payload && payload.mode === "main") {
       // 3줄 전체 기준 유효옵션 충족 시 종료
       if (hasSatisfiedCandidateMain(payload.criteria)) {
-        const partsType = getSelectedPartsTypeSafe();
+        const context = {
+          cubeItemID: getSelectedCubeIdSafe(),
+          partsType: getSelectedPartsTypeSafe(),
+          level: getSelectedLevelSafe()
+        };
         applyAutoHitUIForCandidates(cand => {
-          return isMainValidSet(cand, partsType, payload.criteria.iedMaxN, payload.criteria.bossMaxM);
+          return isMainValidSet(cand, context, payload.criteria);
         });
         stopAuto();
         return;
       }      
     } else if (payload && payload.mode === "stat") {
       if (hasSatisfiedCandidateStat(payload.criteria)) {
         const partsType = getSelectedPartsTypeSafe();
         applyAutoHitUIForCandidates(cand => {
           return isStatValidSet(cand, partsType, payload.criteria);
         });
         stopAuto();
         return;
       }
     }
 
     // 다시 반복
     autoTimer = setTimeout(() => autoStep(payload), 0);
   }
 
   function startAuto() {
     if (autoRunning) return;
 
     if (!isSupportedParts()) {
       alert("선택한 부위/큐브 종류에서는 자동 돌리기를 사용할 수 없습니다.");
       return;
@@ -754,53 +798,56 @@
     const iedMaxN = Number(iedSelect.value);
     if (isNaN(iedMaxN) || iedMaxN < 0 || iedMaxN > 3) {
       alert("IED 줄 수가 올바르지 않습니다.");
       return;
     }
     
     let bossMaxM = 0;
     if (isWeaponOrSecondarySelected()) {
       const bossSelect = document.getElementById("autoMainBossMin");
       if (!bossSelect) {
         alert("윗잠재 자동돌리기 Boss 설정 UI를 찾을 수 없습니다.");
         return;
       }
       bossMaxM = Number(bossSelect.value);
     
       // ✅ Boss dropdown은 0 ~ (3 - iedMaxN) 로 제한(요구사항)
       const maxBoss = 3 - iedMaxN;
       if (isNaN(bossMaxM) || bossMaxM < 0 || bossMaxM > maxBoss) {
         alert("Boss 최대 줄 수가 올바르지 않습니다.");
         return;
       }
     }
     
     autoRunning = true;
     updateAutoButton(true);
+
+    const seekDepartureInput = document.getElementById("autoMainSeekDeparture");
+    const seekDeparture = seekDepartureInput ? seekDepartureInput.checked : false;
     
     // ✅ criteria에 iedMaxN 전달
-    autoStep({ mode: "main", criteria: { iedMaxN, bossMaxM } });
+    autoStep({ mode: "main", criteria: { iedMaxN, bossMaxM, seekDeparture } });
     
   }
 
   function stopAuto() {
     autoRunning = false;
     if (autoTimer) {
       clearTimeout(autoTimer);
       autoTimer = null;
     }
     updateAutoButton(false);
   }
 
   // DOM 준비 후 이벤트 연결
   window.addEventListener("DOMContentLoaded", () => {
     const autoBtn = document.getElementById("autoRollBtn");
     if (autoBtn) {
       autoBtn.addEventListener("click", () => {
         if (autoRunning) {
           stopAuto();
         } else {
           startAuto();
         }
       });
       // 적용 및 리셋 클릭 시 하이라이트 제거
       const applyResetBtn = document.getElementById("applyResetBtn");
